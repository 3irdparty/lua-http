<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
  <title>lua-http</title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
  <link rel="stylesheet" href="site.css">
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<div class="meta">
<header>
<h1 class="title">lua-http</h1>
<h1 class="subtitle">HTTP library for Lua</h1>
</header>
<nav id="TOC">
<ul>
<li><a href="#introduction">Introduction</a><ul>
<li><a href="#common-use-cases">Common use cases</a><ul>
<li><a href="#retrieving-a-document">Retrieving A Document</a></li>
<li><a href="#http.websocket-example">WebSocket Communications</a></li>
</ul></li>
<li><a href="#asynchronous-operation">Asynchronous Operation</a></li>
<li><a href="#conventions">Conventions</a><ul>
<li><a href="#http">HTTP</a></li>
<li><a href="#errors">Errors</a></li>
</ul></li>
<li><a href="#terminology">Terminology</a></li>
</ul></li>
<li><a href="#interfaces">Interfaces</a><ul>
<li><a href="#connection">connection</a><ul>
<li><a href="#connection.type"><code>connection.type</code> <!-- --></a></li>
<li><a href="#connection.version"><code>connection.version</code> <!-- --></a></li>
<li><a href="#connection:connect"><code>connection:connect(timeout)</code> <!-- --></a></li>
<li><a href="#connection:checktls"><code>connection:checktls()</code> <!-- --></a></li>
<li><a href="#connection:localname"><code>connection:localname()</code> <!-- --></a></li>
<li><a href="#connection:peername"><code>connection:peername()</code> <!-- --></a></li>
<li><a href="#connection:shutdown"><code>connection:shutdown()</code> <!-- --></a></li>
<li><a href="#connection:close"><code>connection:close()</code> <!-- --></a></li>
<li><a href="#connection:new_stream"><code>connection:new_stream()</code> <!-- --></a></li>
<li><a href="#connection:get_next_incoming_stream"><code>connection:get_next_incoming_stream(timeout)</code> <!-- --></a></li>
</ul></li>
<li><a href="#stream">stream</a><ul>
<li><a href="#stream.connection"><code>stream.connection</code> <!-- --></a></li>
<li><a href="#stream:get_headers"><code>stream:get_headers(timeout)</code> <!-- --></a></li>
<li><a href="#stream:write_headers"><code>stream:write_headers(headers, end_stream, timeout)</code> <!-- --></a></li>
<li><a href="#stream:get_next_chunk"><code>stream:get_next_chunk(timeout)</code> <!-- --></a></li>
<li><a href="#stream:unget"><code>stream:unget(str)</code> <!-- --></a></li>
<li><a href="#stream:write_chunk"><code>stream:write_chunk(chunk, end_stream, timeout)</code> <!-- --></a></li>
<li><a href="#stream:shutdown"><code>stream:shutdown()</code> <!-- --></a></li>
</ul></li>
</ul></li>
<li><a href="#modules">Modules</a><ul>
<li><a href="#http.bit">http.bit</a><ul>
<li><a href="#http.bit.band"><code>band(a, b)</code> <!-- --></a></li>
<li><a href="#http.bit.bor"><code>bor(a, b)</code> <!-- --></a></li>
<li><a href="#http.bit.bxor"><code>bxor(a, b)</code> <!-- --></a></li>
<li><a href="#http.bit-example">Example</a></li>
</ul></li>
<li><a href="#http.client">http.client</a><ul>
<li><a href="#http.client.connect"><code>connect(options, timeout)</code> <!-- --></a></li>
<li><a href="#http.client.negotiate"><code>negotiate(socket, options, timeout)</code> <!-- --></a></li>
</ul></li>
<li><a href="#http.h1_connection">http.h1_connection</a><ul>
<li><a href="#connection.new"><code>new(socket, conn_type, version)</code> <!-- --></a></li>
<li><a href="#http.h1_connection.version"><code>h1_connection.version</code> <!-- --></a></li>
<li><a href="#http.h1_connection:clearerr"><code>h1_connection:clearerr(...)</code> <!-- --></a></li>
<li><a href="#http.h1_connection:take_socket"><code>h1_connection:take_socket()</code> <!-- --></a></li>
<li><a href="#http.h1_connection:flush"><code>h1_connection:flush(...)</code> <!-- --></a></li>
<li><a href="#http.h1_connection:read_request_line"><code>h1_connection:read_request_line(timeout)</code> <!-- --></a></li>
<li><a href="#http.h1_connection:read_status_line"><code>h1_connection:read_status_line(timeout)</code> <!-- --></a></li>
<li><a href="#http.h1_connection:read_header"><code>h1_connection:read_header(timeout)</code> <!-- --></a></li>
<li><a href="#http.h1_connection:read_headers_done"><code>h1_connection:read_headers_done(timeout)</code> <!-- --></a></li>
<li><a href="#http.h1_connection:read_body_by_length"><code>h1_connection:read_body_by_length(len, timeout)</code> <!-- --></a></li>
<li><a href="#http.h1_connection:read_body_till_close"><code>h1_connection:read_body_till_close(timeout)</code> <!-- --></a></li>
<li><a href="#http.h1_connection:read_body_chunk"><code>h1_connection:read_body_chunk(timeout)</code> <!-- --></a></li>
<li><a href="#http.h1_connection:write_request_line"><code>h1_connection:write_request_line(method, path, httpversion, timeout)</code> <!-- --></a></li>
<li><a href="#http.h1_connection:write_status_line"><code>h1_connection:write_status_line(httpversion, status_code, reason_phrase, timeout)</code> <!-- --></a></li>
<li><a href="#http.h1_connection:write_header"><code>h1_connection:write_header(k, v, timeout)</code> <!-- --></a></li>
<li><a href="#http.h1_connection:write_headers_done"><code>h1_connection:write_headers_done(timeout)</code> <!-- --></a></li>
<li><a href="#http.h1_connection:write_body_chunk"><code>h1_connection:write_body_chunk(chunk, chunk_ext, timeout)</code> <!-- --></a></li>
<li><a href="#http.h1_connection:write_body_last_chunk"><code>h1_connection:write_body_last_chunk(chunk_ext, timeout)</code> <!-- --></a></li>
<li><a href="#http.h1_connection:write_body_plain"><code>h1_connection:write_body_plain(body, timeout)</code> <!-- --></a></li>
</ul></li>
<li><a href="#http.h1_reason_phrases">http.h1_reason_phrases</a><ul>
<li><a href="#http.h1_reason_phrases-example">Example</a></li>
</ul></li>
<li><a href="#http.h1_stream">http.h1_stream</a><ul>
<li><a href="#http.h1_stream:set_state"><code>h1_stream:set_state(new)</code> <!-- --></a></li>
<li><a href="#http.h1_stream:read_headers"><code>h1_stream:read_headers(timeout)</code> <!-- --></a></li>
</ul></li>
<li><a href="#http.h2_connection">http.h2_connection</a><ul>
<li><a href="#http.h2_connection.new"><code>new(socket, conn_type, settings)</code> <!-- --></a></li>
<li><a href="#http.h2_connection.version"><code>h2_connection.version</code> <!-- --></a></li>
<li><a href="#http.h2_connection:pollfd"><code>h2_connection:pollfd()</code> <!-- --></a></li>
<li><a href="#http.h2_connection:events"><code>h2_connection:events()</code> <!-- --></a></li>
<li><a href="#http.h2_connection:timeout"><code>h2_connection:timeout()</code> <!-- --></a></li>
<li><a href="#http.h2_connection:empty"><code>h2_connection:empty()</code> <!-- --></a></li>
<li><a href="#http.h2_connection:step"><code>h2_connection:step(timeout)</code> <!-- --></a></li>
<li><a href="#http.h2_connection:loop"><code>h2_connection:loop(timeout)</code> <!-- --></a></li>
<li><a href="#http.h2_connection:connect"><code>h2_connection:connect(timeout)</code> <!-- --></a></li>
<li><a href="#http.h2_connection:checktls"><code>h2_connection:checktls()</code> <!-- --></a></li>
<li><a href="#http.h2_connection:localname"><code>h2_connection:localname()</code> <!-- --></a></li>
<li><a href="#http.h2_connection:peername"><code>h2_connection:peername()</code> <!-- --></a></li>
<li><a href="#http.h2_connection:shutdown"><code>h2_connection:shutdown()</code> <!-- --></a></li>
<li><a href="#http.h2_connection:close"><code>h2_connection:close()</code> <!-- --></a></li>
<li><a href="#http.h2_connection:new_stream"><code>h2_connection:new_stream(id)</code> <!-- --></a></li>
<li><a href="#http.h2_connection:get_next_incoming_stream"><code>h2_connection:get_next_incoming_stream(timeout)</code> <!-- --></a></li>
<li><a href="#http.h2_connection:read_http2_frame"><code>h2_connection:read_http2_frame(timeout)</code> <!-- --></a></li>
<li><a href="#http.h2_connection:write_http2_frame"><code>h2_connection:write_http2_frame(typ, flags, streamid, payload, timeout)</code> <!-- --></a></li>
<li><a href="#http.h2_connection:ping"><code>h2_connection:ping(timeout)</code> <!-- --></a></li>
<li><a href="#http.h2_connection:write_window_update"><code>h2_connection:write_window_update(inc, timeout)</code> <!-- --></a></li>
<li><a href="#http.h2_connection:write_goaway_frame"><code>h2_connection:write_goaway_frame(last_stream_id, err_code, debug_msg)</code> <!-- --></a></li>
<li><a href="#http.h2_connection:set_peer_settings"><code>h2_connection:set_peer_settings(peer_settings)</code> <!-- --></a></li>
<li><a href="#http.h2_connection:ack_settings"><code>h2_connection:ack_settings()</code> <!-- --></a></li>
<li><a href="#http.h2_connection:settings"><code>h2_connection:settings(tbl, timeout)</code> <!-- --></a></li>
</ul></li>
<li><a href="#http.h2_error">http.h2_error</a><ul>
<li><a href="#http.h2_error.errors"><code>errors</code> <!-- --></a></li>
<li><a href="#http.h2_error.is"><code>is(ob)</code> <!-- --></a></li>
<li><a href="#http.h2_error:new"><code>h2_error:new(ob)</code> <!-- --></a></li>
<li><a href="#http.h2_error:new_traceback"><code>h2_error:new_traceback(message, stream_error, lvl)</code> <!-- --></a></li>
<li><a href="#http.h2_error:error"><code>h2_error:error(message, stream_error, lvl)</code> <!-- --></a></li>
<li><a href="#http.h2_error:assert"><code>h2_error:assert(cond, ...)</code> <!-- --></a></li>
</ul></li>
<li><a href="#http.h2_stream">http.h2_stream</a><ul>
<li><a href="#http.h2_stream:set_state"><code>h2_stream:set_state(new)</code> <!-- --></a></li>
<li><a href="#http.h2_stream:reprioritise"><code>h2_stream:reprioritise(child, exclusive)</code> <!-- --></a></li>
<li><a href="#http.h2_stream:write_http2_frame"><code>h2_stream:write_http2_frame(typ, flags, payload, timeout)</code> <!-- --></a></li>
<li><a href="#http.h2_stream:write_data_frame"><code>h2_stream:write_data_frame(payload, end_stream, padded, timeout)</code> <!-- --></a></li>
<li><a href="#http.h2_stream:write_headers_frame"><code>h2_stream:write_headers_frame(payload, end_stream, end_headers, padded, exclusive, stream_dep, weight, timeout)</code> <!-- --></a></li>
<li><a href="#http.h2_stream:write_priority_frame"><code>h2_stream:write_priority_frame(exclusive, stream_dep, weight, timeout)</code> <!-- --></a></li>
<li><a href="#http.h2_stream:write_rst_stream"><code>h2_stream:write_rst_stream(err_code, timeout)</code> <!-- --></a></li>
<li><a href="#http.h2_stream:write_settings_frame"><code>h2_stream:write_settings_frame(ACK, settings, timeout)</code> <!-- --></a></li>
<li><a href="#http.h2_stream:write_push_promise_frame"><code>h2_stream:write_push_promise_frame(promised_stream_id, payload, end_headers, padded, timeout)</code> <!-- --></a></li>
<li><a href="#http.h2_stream:push_promise"><code>h2_stream:push_promise(headers, timeout)</code> <!-- --></a></li>
<li><a href="#http.h2_stream:write_ping_frame"><code>h2_stream:write_ping_frame(ACK, payload, timeout)</code> <!-- --></a></li>
<li><a href="#http.h2_stream:write_goaway_frame"><code>h2_stream:write_goaway_frame(last_streamid, err_code, debug_msg, timeout)</code> <!-- --></a></li>
<li><a href="#http.h2_stream:write_window_update_frame"><code>h2_stream:write_window_update_frame(inc, timeout)</code> <!-- --></a></li>
<li><a href="#http.h2_stream:write_window_update"><code>h2_stream:write_window_update(inc)</code> <!-- --></a></li>
<li><a href="#http.h2_stream:read_continuation"><code>h2_stream:read_continuation(timeout)</code> <!-- --></a></li>
<li><a href="#http.h2_stream:write_continuation_frame"><code>h2_stream:write_continuation_frame(payload, end_headers, timeout)</code> <!-- --></a></li>
</ul></li>
<li><a href="#http.headers">http.headers</a><ul>
<li><a href="#http.headers.new"><code>new()</code> <!-- --></a></li>
<li><a href="#http.headers:len"><code>headers:len()</code> <!-- --></a></li>
<li><a href="#http.headers:clone"><code>headers:clone()</code> <!-- --></a></li>
<li><a href="#http.headers:append"><code>headers:append(name, value, never_index)</code> <!-- --></a></li>
<li><a href="#http.headers:each"><code>headers:each()</code> <!-- --></a></li>
<li><a href="#http.headers:has"><code>headers:has(name)</code> <!-- --></a></li>
<li><a href="#http.headers:delete"><code>headers:delete(name)</code> <!-- --></a></li>
<li><a href="#http.headers:geti"><code>headers:geti(i)</code> <!-- --></a></li>
<li><a href="#http.headers:get_as_sequence"><code>headers:get_as_sequence(name)</code> <!-- --></a></li>
<li><a href="#http.headers:get"><code>headers:get(name)</code> <!-- --></a></li>
<li><a href="#http.headers:get_comma_separated"><code>headers:get_comma_separated(name)</code> <!-- --></a></li>
<li><a href="#http.headers:modifyi"><code>headers:modifyi(i, value, never_index)</code> <!-- --></a></li>
<li><a href="#http.headers:upsert"><code>headers:upsert(name, value, never_index)</code> <!-- --></a></li>
<li><a href="#http.headers:sort"><code>headers:sort()</code> <!-- --></a></li>
<li><a href="#http.headers:dump"><code>headers:dump(file, prefix)</code> <!-- --></a></li>
</ul></li>
<li><a href="#http.hpack">http.hpack</a><ul>
<li><a href="#http.hpack.new"><code>new(SETTINGS_HEADER_TABLE_SIZE)</code> <!-- --></a></li>
<li><a href="#http.hpack:append_data"><code>hpack_context:append_data(val)</code> <!-- --></a></li>
<li><a href="#http.hpack:render_data"><code>hpack_context:render_data()</code> <!-- --></a></li>
<li><a href="#http.hpack:clear_data"><code>hpack_context:clear_data()</code> <!-- --></a></li>
<li><a href="#http.hpack:evict_from_dynamic_table"><code>hpack_context:evict_from_dynamic_table()</code> <!-- --></a></li>
<li><a href="#http.hpack:dynamic_table_tostring"><code>hpack_context:dynamic_table_tostring()</code> <!-- --></a></li>
<li><a href="#http.hpack:set_max_dynamic_table_size"><code>hpack_context:set_max_dynamic_table_size(SETTINGS_HEADER_TABLE_SIZE)</code> <!-- --></a></li>
<li><a href="#http.hpack:encode_max_size"><code>hpack_context:encode_max_size(val)</code> <!-- --></a></li>
<li><a href="#http.hpack:resize_dynamic_table"><code>hpack_context:resize_dynamic_table(new_size)</code> <!-- --></a></li>
<li><a href="#http.hpack:add_to_dynamic_table"><code>hpack_context:add_to_dynamic_table(name, value, k)</code> <!-- --></a></li>
<li><a href="#http.hpack:dynamic_table_id_to_index"><code>hpack_context:dynamic_table_id_to_index(id)</code> <!-- --></a></li>
<li><a href="#http.hpack:lookup_pair_index"><code>hpack_context:lookup_pair_index(k)</code> <!-- --></a></li>
<li><a href="#http.hpack:lookup_name_index"><code>hpack_context:lookup_name_index(name)</code> <!-- --></a></li>
<li><a href="#http.hpack:lookup_index"><code>hpack_context:lookup_index(index, allow_single)</code> <!-- --></a></li>
<li><a href="#http.hpack:add_header_indexed"><code>hpack_context:add_header_indexed(name, value, huffman)</code> <!-- --></a></li>
<li><a href="#http.hpack:add_header_never_indexed"><code>hpack_context:add_header_never_indexed(name, value, huffman)</code> <!-- --></a></li>
<li><a href="#http.hpack:encode_headers"><code>hpack_context:encode_headers(headers)</code> <!-- --></a></li>
<li><a href="#http.hpack:decode_headers"><code>hpack_context:decode_headers(payload, header_list, pos)</code> <!-- --></a></li>
</ul></li>
<li><a href="#http.hsts">http.hsts</a><ul>
<li><a href="#http.hsts.new_store"><code>new_store()</code> <!-- --></a></li>
<li><a href="#http.hsts:clone"><code>hsts_store:clone()</code> <!-- --></a></li>
<li><a href="#http.hsts:store"><code>hsts_store:store(host, directives)</code> <!-- --></a></li>
<li><a href="#http.hsts:check"><code>hsts_store:check(host)</code> <!-- --></a></li>
<li><a href="#http.hsts:clean"><code>hsts_store:clean()</code> <!-- --></a></li>
</ul></li>
<li><a href="#http.proxies">http.proxies</a><ul>
<li><a href="#http.proxies.new"><code>new()</code> <!-- --></a></li>
<li><a href="#http.proxies:update"><code>proxies:update(getenv)</code> <!-- --></a></li>
<li><a href="#http.proxies:choose"><code>proxies:choose(scheme, host)</code> <!-- --></a></li>
</ul></li>
<li><a href="#http.request">http.request</a><ul>
<li><a href="#http.request.new_from_uri"><code>new_from_uri(uri)</code> <!-- --></a></li>
<li><a href="#http.request.new_connect"><code>new_connect(uri, connect_authority)</code> <!-- --></a></li>
<li><a href="#http.request.host"><code>request.host</code> <!-- --></a></li>
<li><a href="#http.request.port"><code>request.port</code> <!-- --></a></li>
<li><a href="#http.request.tls"><code>request.tls</code> <!-- --></a></li>
<li><a href="#http.request.ctx"><code>request.ctx</code> <!-- --></a></li>
<li><a href="#http.request.sendname"><code>request.sendname</code> <!-- --></a></li>
<li><a href="#http.request.version"><code>request.version</code> <!-- --></a></li>
<li><a href="#http.request.proxy"><code>request.proxy</code> <!-- --></a></li>
<li><a href="#http.request.headers"><code>request.headers</code> <!-- --></a></li>
<li><a href="#http.request.follow_redirects"><code>request.follow_redirects</code> <!-- --></a></li>
<li><a href="#http.request.expect_100_timeout"><code>request.expect_100_timeout</code> <!-- --></a></li>
<li><a href="#http.request.max_redirects"><code>request.max_redirects</code> <!-- --></a></li>
<li><a href="#http.request.post301"><code>request.post301</code> <!-- --></a></li>
<li><a href="#http.request.post302"><code>request.post302</code> <!-- --></a></li>
<li><a href="#http.request:clone"><code>request:clone()</code> <!-- --></a></li>
<li><a href="#http.request:handle_redirect"><code>request:handle_redirect(headers)</code> <!-- --></a></li>
<li><a href="#http.request:to_uri"><code>request:to_uri(with_userinfo)</code> <!-- --></a></li>
<li><a href="#http.request:set_body"><code>request:set_body(body)</code> <!-- --></a></li>
<li><a href="#http.request:timeout"><code>request:go(timeout)</code> <!-- --></a></li>
</ul></li>
<li><a href="#http.server">http.server</a><ul>
<li><a href="#http.server.connect"><code>listen(options)</code> <!-- --></a></li>
<li><a href="#http.server:onerror"><code>server:onerror(new_handler)</code> <!-- --></a></li>
<li><a href="#http.server:listen"><code>server:listen(timeout)</code> <!-- --></a></li>
<li><a href="#http.server:localname"><code>server:localname()</code> <!-- --></a></li>
<li><a href="#http.server:pause"><code>server:pause()</code> <!-- --></a></li>
<li><a href="#http.server:resume"><code>server:resume()</code> <!-- --></a></li>
<li><a href="#http.server:close"><code>server:close()</code> <!-- --></a></li>
<li><a href="#http.server:pollfd"><code>server:pollfd()</code> <!-- --></a></li>
<li><a href="#http.server:events"><code>server:events()</code> <!-- --></a></li>
<li><a href="#http.server:timeout"><code>server:timeout()</code> <!-- --></a></li>
<li><a href="#http.server:empty"><code>server:empty()</code> <!-- --></a></li>
<li><a href="#http.server:step"><code>server:step()</code> <!-- --></a></li>
<li><a href="#http.server:loop"><code>server:loop()</code> <!-- --></a></li>
<li><a href="#http.server:add_socket"><code>server:add_socket(socket)</code> <!-- --></a></li>
</ul></li>
<li><a href="#http.socks">http.socks</a><ul>
<li><a href="#http.socks.connect"><code>connect(uri)</code> <!-- --></a></li>
<li><a href="#http.socks.fdopen"><code>fdopen(socket)</code> <!-- --></a></li>
<li><a href="#http.socks.needs_resolve"><code>socks.needs_resolve</code> <!-- --></a></li>
<li><a href="#http.socks:clone"><code>socks:clone()</code> <!-- --></a></li>
<li><a href="#http.socks:add_username_password_auth"><code>socks:add_username_password_auth(username, password)</code> <!-- --></a></li>
<li><a href="#http.socks:negotiate"><code>socks:negotiate(host, port, timeout)</code> <!-- --></a></li>
<li><a href="#http.socks:close"><code>socks:close()</code> <!-- --></a></li>
<li><a href="#http.socks:take_socket"><code>socks:take_socket()</code> <!-- --></a></li>
</ul></li>
<li><a href="#http.stream_common">http.stream_common</a><ul>
<li><a href="#http.stream_common:checktls"><code>stream:checktls()</code> <!-- --></a></li>
<li><a href="#http.stream_common:localname"><code>stream:localname()</code> <!-- --></a></li>
<li><a href="#http.stream_common:peername"><code>stream:peername()</code> <!-- --></a></li>
<li><a href="#http.stream_common:write_continue"><code>stream:write_continue(timeout)</code> <!-- --></a></li>
<li><a href="#http.stream_common:each_chunk"><code>stream:each_chunk()</code> <!-- --></a></li>
<li><a href="#http.stream_common:get_body_as_string"><code>stream:get_body_as_string(timeout)</code> <!-- --></a></li>
<li><a href="#http.stream_common:get_body_chars"><code>stream:get_body_chars(n, timeout)</code> <!-- --></a></li>
<li><a href="#http.stream_common:get_body_until"><code>stream:get_body_until(pattern, plain, include_pattern, timeout)</code> <!-- --></a></li>
<li><a href="#http.stream_common:save_body_to_file"><code>stream:save_body_to_file(file, timeout)</code> <!-- --></a></li>
<li><a href="#http.stream_common:get_body_as_file"><code>stream:get_body_as_file(timeout)</code> <!-- --></a></li>
<li><a href="#http.stream_common:write_body_from_string"><code>stream:write_body_from_string(str, timeout)</code> <!-- --></a></li>
<li><a href="#http.stream_common:write_body_from_file"><code>stream:write_body_from_file(file, timeout)</code> <!-- --></a></li>
</ul></li>
<li><a href="#http.tls">http.tls</a><ul>
<li><a href="#http.tls.has_alpn"><code>has_alpn</code> <!-- --></a></li>
<li><a href="#http.tls.modern_cipher_list"><code>modern_cipher_list</code> <!-- --></a></li>
<li><a href="#http.tls.intermediate_cipher_list"><code>intermediate_cipher_list</code> <!-- --></a></li>
<li><a href="#http.tls.banned_ciphers"><code>banned_ciphers</code> <!-- --></a></li>
<li><a href="#http.tls.new_client_context"><code>new_client_context()</code> <!-- --></a></li>
<li><a href="#http.tls.new_server_context"><code>new_server_context()</code> <!-- --></a></li>
</ul></li>
<li><a href="#http.util">http.util</a><ul>
<li><a href="#http.util.encodeURI"><code>encodeURI(str)</code> <!-- --></a></li>
<li><a href="#http.util.encodeURIComponent"><code>encodeURIComponent(str)</code> <!-- --></a></li>
<li><a href="#http.util.decodeURI"><code>decodeURI(str)</code> <!-- --></a></li>
<li><a href="#http.util.decodeURIComponent"><code>decodeURIComponent(str)</code> <!-- --></a></li>
<li><a href="#http.util.query_args"><code>query_args(str)</code> <!-- --></a></li>
<li><a href="#http.util.dict_to_query"><code>dict_to_query(dict)</code> <!-- --></a></li>
<li><a href="#http.util.resolve_relative_path"><code>resolve_relative_path(orig_path, relative_path)</code> <!-- --></a></li>
<li><a href="#http.util.scheme_to_port"><code>scheme_to_port</code> <!-- --></a></li>
<li><a href="#http.util.split_authority"><code>split_authority(authority, scheme)</code> <!-- --></a></li>
<li><a href="#http.util.to_authority"><code>to_authority(host, port, scheme)</code> <!-- --></a></li>
<li><a href="#http.util.imf_date"><code>imf_date(time)</code> <!-- --></a></li>
<li><a href="#http.util.maybe_quote"><code>maybe_quote(str)</code> <!-- --></a></li>
</ul></li>
<li><a href="#http.version">http.version</a><ul>
<li><a href="#http.version.name"><code>name</code> <!-- --></a></li>
<li><a href="#http.version.version"><code>version</code> <!-- --></a></li>
</ul></li>
<li><a href="#http.websocket">http.websocket</a><ul>
<li><a href="#http.websocket.new_from_uri"><code>new_from_uri(uri, protocols)</code> <!-- --></a></li>
<li><a href="#http.websocket.new_from_stream"><code>new_from_stream(stream, headers)</code> <!-- --></a></li>
<li><a href="#http.websocket.close_timeout"><code>websocket.close_timeout</code> <!-- --></a></li>
<li><a href="#http.websocket:accept"><code>websocket:accept(options, timeout)</code> <!-- --></a></li>
<li><a href="#http.websocket:connect"><code>websocket:connect(timeout)</code> <!-- --></a></li>
<li><a href="#http.websocket:receive"><code>websocket:receive(timeout)</code> <!-- --></a></li>
<li><a href="#http.websocket:each"><code>websocket:each()</code> <!-- --></a></li>
<li><a href="#http.websocket:send_frame"><code>websocket:send_frame(frame, timeout)</code> <!-- --></a></li>
<li><a href="#http.websocket:send"><code>websocket:send(data, opcode, timeout)</code> <!-- --></a></li>
<li><a href="#http.websocket:send_ping"><code>websocket:send_ping(data, timeout)</code> <!-- --></a></li>
<li><a href="#http.websocket:send_pong"><code>websocket:send_pong(data, timeout)</code> <!-- --></a></li>
<li><a href="#http.websocket:close"><code>websocket:close(code, reason, timeout)</code> <!-- --></a></li>
</ul></li>
<li><a href="#http.zlib">http.zlib</a><ul>
<li><a href="#http.zlib.engine"><code>engine</code> <!-- --></a></li>
<li><a href="#http.zlib.inflate"><code>inflate()</code> <!-- --></a></li>
<li><a href="#http.zlib.deflate"><code>deflate()</code> <!-- --></a></li>
<li><a href="#http.zlib-example">Example</a></li>
</ul></li>
<li><a href="#http.compat.prosody">http.compat.prosody</a><ul>
<li><a href="#http.compat.prosody.request"><code>request(url, ex, callback)</code> <!-- --></a></li>
<li><a href="#http.compat.prosody-example">Example</a></li>
</ul></li>
<li><a href="#http.compat.socket">http.compat.socket</a><ul>
<li><a href="#http.compat.socket-example">Example</a></li>
</ul></li>
</ul></li>
<li><a href="#links">Links</a></li>
</ul>
</nav>
</div>
<main>
<section id="introduction" class="level1">
<h1>Introduction</h1>
<p>lua-http is an performant, capable Hyper Text Transfer Protocol (HTTP) and WebSocket (WS) library for Lua 5.1, 5.2, 5.3 and LuaJIT. The software supports x86, x64 and Arm based systems, as well as GNU/Linux, OSX, FreeBSD and others [1]. lua-http can be utilized as a server or client and includes the following features:</p>
<ul>
<li>HTTP 1 and HTTP 2 as specified by <a href="https://tools.ietf.org/html/rfc7230">RFC 7230</a> and <a href="https://tools.ietf.org/html/rfc7540">RFC 7540</a></li>
<li>WebSockets as specified by <a href="https://tools.ietf.org/html/rfc6455">RFC 6455</a> including ping/pong, binary data transfer and TLS encryption</li>
<li>Transport Layer Security (TLS) - lua-http supports HTTPS and WSS via <a href="https://github.com/wahern/luaossl">luaossl</a>.</li>
<li>Fully asynchronous API that does not block the current thread when executing operations that typically block</li>
<li>Easy integration into other event-loop based application models</li>
</ul>
<p>lua-http was written to fill a gap in the Lua ecosystem by providing an HTTP and WebSocket library with the following traits:</p>
<ul>
<li>Asynchronous and performant</li>
<li>Can be used without forcing the developer to follow a specific pattern. Conversely, the library can be adapted to many common patterns.</li>
<li>Can be used at a very high level without need to understand the transportation of HTTP data (other than connection addresses).</li>
<li>Provides a rich low level API, if desired, for creating powerful HTTP based tools at the protocol level.</li>
</ul>
<p>As a result of these design goals, the library is simple and un-obtrusive and can accommodate tens of thousands of connections on commodity hardware.</p>
<p>lua-http is a flexible HTTP and WebSocket library that allows developers to concentrate on line-of-business features when building Internet enabled applications. If you are looking for a way to streamline development of an internet enabled application, enable HTTP networking in your game, create a new Internet Of Things (IoT) system, or write a performant custom web server for a specific use case, lua-http has the tools you need.</p>
<p>[1] _lua-http is pure lua code and will therefore support any platform that Lua 5.1 or greater supports. Where lua-http can run is mainly limited by where cqueues works (which at the time of writing is BSDs, Linux, OSX, Solaris): if you can port cqueues to it, lua-http should automatically work._</p>
<section id="common-use-cases" class="level2">
<h2>Common use cases</h2>
<p>The following are two simple demonstrations of how the lua-http library can be used:</p>
<section id="retrieving-a-document" class="level3">
<h3>Retrieving A Document</h3>
<p>The highest level interface for clients is <a href="#http.request"><em>http.request</em></a>. By constructing a <a href="#http.request"><em>request</em></a> object from a URI using <a href="#http.request.new_from_uri"><code>new_from_uri</code></a> and immediately evaluating it, you can easily fetch an HTTP resource.</p>
<div class="sourceCode"><pre class="sourceCode lua"><code class="sourceCode lua"><span class="kw">local</span> http_request <span class="ot">=</span> <span class="fu">require</span> <span class="st">&quot;http.request&quot;</span>
<span class="kw">local</span> headers<span class="ot">,</span> stream <span class="ot">=</span> <span class="fu">assert</span><span class="ot">(</span>http_request<span class="ot">.</span>new_from_uri<span class="ot">(</span><span class="st">&quot;http://example.com&quot;</span><span class="ot">)</span>:go<span class="ot">())</span>
<span class="kw">local</span> body <span class="ot">=</span> <span class="fu">assert</span><span class="ot">(</span>stream:get_body_as_string<span class="ot">())</span>
<span class="kw">if</span> headers:get <span class="st">&quot;:status&quot;</span> <span class="ot">~=</span> <span class="st">&quot;200&quot;</span> <span class="kw">then</span>
    <span class="fu">error</span><span class="ot">(</span>body<span class="ot">)</span>
<span class="kw">end</span>
<span class="fu">print</span><span class="ot">(</span>body<span class="ot">)</span></code></pre></div>
</section>
<section id="http.websocket-example" class="level3">
<h3>WebSocket Communications</h3>
<p>To request information from a WebSocket server, use the <code>websocket</code> module to create a new WebSocket client.</p>
<div class="sourceCode"><pre class="sourceCode lua"><code class="sourceCode lua"><span class="kw">local</span> websocket <span class="ot">=</span> <span class="fu">require</span> <span class="st">&quot;http.websocket&quot;</span>
<span class="kw">local</span> ws <span class="ot">=</span> websocket<span class="ot">.</span>new_from_uri<span class="ot">(</span><span class="st">&quot;wss://echo.websocket.org&quot;</span><span class="ot">)</span>
<span class="fu">assert</span><span class="ot">(</span>ws:<span class="fu">connect</span><span class="ot">())</span>
<span class="fu">assert</span><span class="ot">(</span>ws:send<span class="ot">(</span><span class="st">&quot;koo-eee!&quot;</span><span class="ot">))</span>
<span class="kw">local</span> data <span class="ot">=</span> <span class="fu">assert</span><span class="ot">(</span>ws:receive<span class="ot">())</span>
<span class="fu">assert</span><span class="ot">(</span>data <span class="ot">==</span> <span class="st">&quot;koo-eee!&quot;</span><span class="ot">)</span>
<span class="fu">assert</span><span class="ot">(</span>ws:<span class="fu">close</span><span class="ot">())</span></code></pre></div>
</section>
</section>
<section id="asynchronous-operation" class="level2">
<h2>Asynchronous Operation</h2>
<p>lua-http has been written to perform asynchronously so that it can be used in your application, server or game without blocking your main loop. Asynchronous operations are achieved by utilizing cqueues, a Lua/C library that incorporates Lua yielding and kernel level APIs to reduce CPU usage. All lua-http operations including DNS lookup, TLS negotiation and read/write operations will not block the main application thread when run from inside a cqueue or cqueue enabled &quot;container&quot;. While sometimes it is necessary to block a routine (yield) and wait for external data, any blocking API calls take an optional timeout to ensure good behavior of networked applications and avoid unresponsive or &quot;dead&quot; routines.</p>
<p>Asynchronous operations are one of the most powerful features of lua-http and require no effort on the developers part. For instance, an HTTP server can be instantiated within any Lua main loop and run alongside application code without adversely affecting the main application process. If other cqueue enabled components are integrated within a cqueue loop, the application is entirely event driven through kernel level polling APIs.</p>
<p>cqueues can be used in conjunction with lua-http to integrate other features into your lua application and create powerful, performant, web enabled applications. Some of the examples in this guide will use cqueues for simple demonstrations. For more resources about cqueues, please see:</p>
<ul>
<li><p><a href="http://25thandclement.com/~william/projects/cqueues.html">The cqueues website</a> for more information about the cqueues library.</p></li>
<li><p>cqueues examples can be found with the cqueues source code available through <a href="http://www.25thandclement.com/~william/projects/cqueues.html#download">git or archives</a> or accessed online <a href="https://github.com/wahern/cqueues/tree/master/examples">here</a>.</p></li>
<li><p>For more information on integrating cqueues with other event loop libraries please see <a href="https://github.com/wahern/cqueues/wiki/Integrations-with-other-main-loops">integration with other event loops</a>.</p></li>
<li><p>For other libraries that use cqueues such as asynchronous APIs for Redis and PostgreSQL, please see <a href="https://github.com/wahern/cqueues/wiki/Libraries-that-use-cqueues">the cqueues wiki entry here</a>.</p></li>
</ul>
</section>
<section id="conventions" class="level2">
<h2>Conventions</h2>
<p>The following is a list of API conventions and general reference:</p>
<section id="http" class="level3">
<h3>HTTP</h3>
<ul>
<li><p>HTTP 1 request and status line fields are passed around inside of <em><a href="#http.headers">headers</a></em> objects under keys <code>&quot;:authority&quot;</code>, <code>&quot;:method&quot;</code>, <code>&quot;:path&quot;</code>, <code>&quot;:scheme&quot;</code> and <code>&quot;:status&quot;</code> as defined in HTTP 2. As such, they are all kept in string form (important to remember for the <code>:status</code> field).</p></li>
<li><p>Header fields should always be used with lower case keys.</p></li>
</ul>
</section>
<section id="errors" class="level3">
<h3>Errors</h3>
<ul>
<li><p>Invalid function parameters will throw a lua error (if validated).</p></li>
<li><p>Errors are returned as <code>nil</code>, error, errno unless noted otherwise.</p></li>
<li><p>Some HTTP 2 operations return/throw special <a href="#http.h2_error">http 2 error objects</a>.</p></li>
</ul>
</section>
</section>
<section id="terminology" class="level2">
<h2>Terminology</h2>
<p>Much lua-http terminology is borrowed from HTTP 2.</p>
<p><em><a href="#connection">Connection</a></em> - An abstraction over an underlying TCP/IP socket. lua-http currently has two connection types: one for HTTP 1, one for HTTP 2.</p>
<p><em><a href="#stream">Stream</a></em> - A request/response on a connection object. lua-http has two stream types: one for <a href="#http.h1_stream"><em>HTTP 1 streams</em></a>, and one for <a href="#http.h2_stream"><em>HTTP 2 streams</em></a>. They common interfaces are described in <a href="#stream"><em>stream</em></a> and <a href="#http.stream_common"><em>http.stream_common</em></a>.</p>
</section>
</section>
<section id="interfaces" class="level1">
<h1>Interfaces</h1>
<section id="connection" class="level2">
<h2>connection</h2>
<p>lua-http has separate libraries for both HTTP 1 and HTTP 2 type communications. Future protocols will also be supported and exposed as new modules. As HTTP 1 and 2 share common concepts at the connection and stream level, the <em><a href="#connection">connection</a></em> and <em><a href="#stream">stream</a></em> modules have been written to contain common interfaces wherever possible. All <em><a href="#connection">connection</a></em> types expose the following fields:</p>
<section id="connection.type" class="level3">
<h3><code>connection.type</code> <!-- --></h3>
<p>The mode of use for the connection object. Valid values are:</p>
<ul>
<li><code>&quot;client&quot;</code> - Connects to a remote URI</li>
<li><code>&quot;server&quot;</code> - Listens for connection on a local URI</li>
</ul>
</section>
<section id="connection.version" class="level3">
<h3><code>connection.version</code> <!-- --></h3>
<p>The HTTP version number of the connection as a number.</p>
</section>
<section id="connection:connect" class="level3">
<h3><code>connection:connect(timeout)</code> <!-- --></h3>
<p>Completes the connection to the remote server using the address specified, HTTP version and any options specified in the <code>connection.new</code> constructor. The <code>connect</code> function will yield until the connection attempt finishes (success or failure) or until <code>timeout</code> is exceeded. Connecting may include DNS lookups, TLS negotiation and HTTP2 settings exchange. Returns <code>true</code> on success. On failure returns <code>nil</code> and an error message.</p>
</section>
<section id="connection:checktls" class="level3">
<h3><code>connection:checktls()</code> <!-- --></h3>
<p>Checks the socket for a valid Transport Layer Security connection. Returns the luaossl ssl object if the connection is secured. Returns <code>nil</code> and an error message if there is no active TLS session. Please see the <a href="http://25thandclement.com/~william/projects/luaossl.html">luaossl website</a> for more information about the ssl object.</p>
</section>
<section id="connection:localname" class="level3">
<h3><code>connection:localname()</code> <!-- --></h3>
<p>Returns the connection information for the local socket. Returns address family, IP address and port for an external socket. For Unix domain sockets, the function returns <code>AF_UNIX</code> and the path. If the connection object is not connected, returns <code>AF_UNSPEC</code> (0). On error, returns <code>nil</code> an error message and an error number.</p>
</section>
<section id="connection:peername" class="level3">
<h3><code>connection:peername()</code> <!-- --></h3>
<p>Returns the connection information for the socket <em>peer</em> (as in, the next hop). Returns address family, IP address and port for an external socket. For unix sockets, the function returns <code>AF_UNIX</code> and the path. If the connection object is not connected, returns <code>AF_UNSPEC</code> (0). On error, returns <code>nil</code> an error message and an error number.</p>
<p><em>Note: If the client is using a proxy, the :peername() will be the proxy, not the remote server connection.</em></p>
</section>
<section id="connection:shutdown" class="level3">
<h3><code>connection:shutdown()</code> <!-- --></h3>
<p>Performs an orderly shutdown of the connection by closing all streams and calls <code>:shutdown()</code> on the socket. The connection cannot be re-opened.</p>
</section>
<section id="connection:close" class="level3">
<h3><code>connection:close()</code> <!-- --></h3>
<p>Closes a connection and releases operating systems resources. Note that close performs a <code>connection:shutdown()</code> prior to releasing resources.</p>
</section>
<section id="connection:new_stream" class="level3">
<h3><code>connection:new_stream()</code> <!-- --></h3>
<p>Creates a new <a href="#stream"><em>stream</em></a> on the connection. Use <code>:new_stream()</code> to initiate a new http request. In HTTP 1, a new stream can be used for request/response exchanges. In HTTP 2 a new stream can be used for request/response exchanges, organising stream priorities or to initiate a push promise.</p>
</section>
<section id="connection:get_next_incoming_stream" class="level3">
<h3><code>connection:get_next_incoming_stream(timeout)</code> <!-- --></h3>
<p>Returns the next peer initiated <a href="#stream"><em>stream</em></a> on the connection. This function can be used to yield and &quot;listen&quot; for incoming HTTP streams.</p>
</section>
</section>
<section id="stream" class="level2">
<h2>stream</h2>
<p>All stream types expose the following fields and functions. The stream modules also share common functionality available via the <a href="#http.stream_common"><em>http.stream_common</em></a> module.</p>
<section id="stream.connection" class="level3">
<h3><code>stream.connection</code> <!-- --></h3>
<p>The underlying <a href="#connection"><em>connection</em></a> object.</p>
</section>
<section id="stream:get_headers" class="level3">
<h3><code>stream:get_headers(timeout)</code> <!-- --></h3>
<p>Retrieves the next complete headers object (i.e. a block of headers or trailers) from the stream.</p>
</section>
<section id="stream:write_headers" class="level3">
<h3><code>stream:write_headers(headers, end_stream, timeout)</code> <!-- --></h3>
<p>Write the given <a href="#http.headers"><em>headers</em></a> object to the stream. The function takes a flag indicating if this is the last chunk in the stream, if <code>true</code> the stream will be closed. If <code>timeout</code> is specified, the stream will wait for the send to complete until <code>timeout</code> is exceeded.</p>
</section>
<section id="stream:get_next_chunk" class="level3">
<h3><code>stream:get_next_chunk(timeout)</code> <!-- --></h3>
<p>Returns the next chunk of the http body from the socket, otherwise it yields while waiting for input. This function will yield indefinitely, or until <code>timeout</code> is exceeded. If the message is compressed, runs inflate to decompress the data. On error, returns <code>nil</code>, an error message and an error number.</p>
</section>
<section id="stream:unget" class="level3">
<h3><code>stream:unget(str)</code> <!-- --></h3>
<p>Places <code>str</code> back on the incoming data buffer, allowing it to be returned again on a subsequent command (&quot;un-gets&quot; the data). Returns <code>true</code> on success. On failure returns <code>nil</code>, error message and an error number.</p>
</section>
<section id="stream:write_chunk" class="level3">
<h3><code>stream:write_chunk(chunk, end_stream, timeout)</code> <!-- --></h3>
<p>Writes the string <code>chunk</code> to the stream. If <code>end_stream</code> is true, the body will be finalized and the stream will be closed. <code>write_chunk</code> yields indefinitely, or until <code>timeout</code> is exceeded.</p>
</section>
<section id="stream:shutdown" class="level3">
<h3><code>stream:shutdown()</code> <!-- --></h3>
<p>Closes the stream. The resources are released and the stream can no longer be used.</p>
</section>
</section>
</section>
<section id="modules" class="level1">
<h1>Modules</h1>
<section id="http.bit" class="level2">
<h2>http.bit</h2>
<p>An abstraction layer over the various lua bit libraries.</p>
<p>Results are only consistent between underlying implementations when parameters and results are in the range of <code>0</code> to <code>0x7fffffff</code>.</p>
<section id="http.bit.band" class="level3">
<h3><code>band(a, b)</code> <!-- --></h3>
<p>Bitwise And operation.</p>
</section>
<section id="http.bit.bor" class="level3">
<h3><code>bor(a, b)</code> <!-- --></h3>
<p>Bitwise Or operation.</p>
</section>
<section id="http.bit.bxor" class="level3">
<h3><code>bxor(a, b)</code> <!-- --></h3>
<p>Bitwise XOr operation.</p>
</section>
<section id="http.bit-example" class="level3">
<h3>Example</h3>
<div class="sourceCode"><pre class="sourceCode lua"><code class="sourceCode lua"><span class="kw">local</span> bit <span class="ot">=</span> <span class="fu">require</span> <span class="st">&quot;http.bit&quot;</span>
<span class="fu">print</span><span class="ot">(</span>bit<span class="ot">.</span>band<span class="ot">(</span><span class="dv">1</span><span class="ot">,</span> <span class="dv">3</span><span class="ot">))</span> <span class="do">--&gt; 1</span></code></pre></div>
</section>
</section>
<section id="http.client" class="level2">
<h2>http.client</h2>
<p>Deals with obtaining a connection to an HTTP server.</p>
<section id="http.client.connect" class="level3">
<h3><code>connect(options, timeout)</code> <!-- --></h3>
<p>This function returns a new connection to an HTTP server. Once a connection has been opened, a stream can be created to start a request/response exchange. Please see <a href="h1_stream.new_stream"><code>h1_stream.new_stream</code></a> and <a href="h2_stream.new_stream"><code>h2_stream.new_stream</code></a> for more information about creating requests.</p>
<ul>
<li><p><code>options</code> is a table containing the options to <a href="#http.client.negotiate"><code>http.client.negotiate</code></a>, plus the following:</p>
<ul>
<li><p><code>family</code> (integer, optional): socket family to use.<br />
defaults to <code>AF_INET</code></p></li>
<li><p><code>host</code> (string): host to connect to.<br />
may be either a hostname or an ip address</p></li>
<li><p><code>port</code> (string|integer): port to connect to in numeric form<br />
e.g. <code>&quot;80&quot;</code> or <code>80</code></p></li>
<li><p><code>path</code> (string): path to connect to (UNIX sockets)</p></li>
<li><code>sendname</code> (string|boolean, optional): the <a href="https://en.wikipedia.org/wiki/Server_Name_Indication">TLS SNI</a> host to send.<br />
defaults to <code>true</code>
<ul>
<li><code>true</code> indicates to copy the <code>host</code> field</li>
<li><code>false</code> disables SNI</li>
</ul></li>
<li><p><code>v6only</code> (boolean, optional): if the <code>IPV6_V6ONLY</code> flag should be set on the underlying socket.</p></li>
</ul></li>
<li><p><code>timeout</code> (optional) is the maximum amount of time (in seconds) to allow for connection to be established.</p>
<p>This includes time for DNS lookup, connection, TLS negotiation (if TLS enabled) and in the case of HTTP 2: settings exchange.</p></li>
</ul>
<section id="http.client.connect-example" class="level4">
<h4>Example</h4>
<p>Connect to a local HTTP server running on port 8000</p>
<div class="sourceCode"><pre class="sourceCode lua"><code class="sourceCode lua"><span class="kw">local</span> http_client <span class="ot">=</span> <span class="fu">require</span> <span class="st">&quot;http.client&quot;</span>
<span class="kw">local</span> myconnection <span class="ot">=</span> http_client<span class="ot">.</span>connect <span class="ot">{</span>
    host <span class="ot">=</span> <span class="st">&quot;localhost&quot;</span><span class="ot">;</span>
    port <span class="ot">=</span> <span class="dv">8000</span><span class="ot">;</span>
    tls <span class="ot">=</span> <span class="kw">false</span><span class="ot">;</span>
<span class="ot">}</span></code></pre></div>
</section>
</section>
<section id="http.client.negotiate" class="level3">
<h3><code>negotiate(socket, options, timeout)</code> <!-- --></h3>
<p>Negotiates the HTTP settings with the remote server. If TLS has been specified, this function instantiates the encryption tunnel. Parameters are as follows:</p>
<ul>
<li><p><code>socket</code> is a cqueues socket object</p></li>
<li><p><code>options</code> is a table containing:</p>
<ul>
<li><p><code>tls</code> (boolean|userdata, optional): the <code>SSL_CTX*</code> to use, or a boolean to indicate the default TLS context.<br />
defaults to <code>true</code>.</p>
<ul>
<li><code>true</code> indicates to use the default TLS settings, see <a href="#http.tls"><em>http.tls</em></a> for information.</li>
<li><code>false</code> means do not negotiate TLS</li>
</ul></li>
<li><code>version</code> (<code>nil</code>|1.0|1.1|2): HTTP version to use.
<ul>
<li><code>nil</code>: attempts HTTP 2 and falls back to HTTP 1.1</li>
<li><code>1.0</code></li>
<li><code>1.1</code></li>
<li><code>2</code></li>
</ul></li>
<li><p><code>h2_settings</code> (table, optional): HTTP 2 settings to use. See <a href="#http.h2_connection"><em>http.h2_connection</em></a> for details</p></li>
</ul></li>
</ul>
</section>
</section>
<section id="http.h1_connection" class="level2">
<h2>http.h1_connection</h2>
<p>The h1_connection module adheres to the <a href="#connection"><em>connection</em></a> interface and provides HTTP 1 and 1.1 specific operations.</p>
<section id="connection.new" class="level3">
<h3><code>new(socket, conn_type, version)</code> <!-- --></h3>
<p>Constructor for a new connection. Takes a socket instance, a connection type string and a numeric HTTP version number. Valid values for the connection type are <code>&quot;client&quot;</code> and <code>&quot;server&quot;</code>. Valid values for the version number are <code>1</code> and <code>1.1</code>. On success returns the newly initialized connection object in a non-connected state. On failure returns <code>nil</code>, an error message and an error number.</p>
</section>
<section id="http.h1_connection.version" class="level3">
<h3><code>h1_connection.version</code> <!-- --></h3>
<p>Specifies the HTTP version used for the connection handshake. Valid values are:</p>
<ul>
<li><code>1.0</code></li>
<li><code>1.1</code></li>
</ul>
</section>
<section id="http.h1_connection:clearerr" class="level3">
<h3><code>h1_connection:clearerr(...)</code> <!-- --></h3>
<p>Clears errors to allow for further read or write operations on the connection. Returns the error number of existing errors. This function is used to recover from known errors.</p>
</section>
<section id="http.h1_connection:take_socket" class="level3">
<h3><code>h1_connection:take_socket()</code> <!-- --></h3>
<p>Used to hand the reference of the connection socket to another object. Resets the socket to defaults and returns the single existing reference of the socket to the calling routine. This function can be used for connection upgrades such as upgrading from HTTP 1 to a WebSocket.</p>
</section>
<section id="http.h1_connection:flush" class="level3">
<h3><code>h1_connection:flush(...)</code> <!-- --></h3>
<p>Flushes all buffered outgoing data on the socket. Returns <code>true</code> on success. Returns <code>false</code> and the error if the socket fails to flush.</p>
</section>
<section id="http.h1_connection:read_request_line" class="level3">
<h3><code>h1_connection:read_request_line(timeout)</code> <!-- --></h3>
<p>Reads a request line from the socket. Returns the request method, requested path and HTTP version for an incoming request. <code>:read_request_line()</code> yields until a <code>&quot;\r\n&quot;</code> terminated chunk is received, or <code>timeout</code> is exceeded. If the incoming chunk is not a valid HTTP request line, <code>nil</code> is returned. On error, returns <code>nil</code>, an error message and an error number.</p>
</section>
<section id="http.h1_connection:read_status_line" class="level3">
<h3><code>h1_connection:read_status_line(timeout)</code> <!-- --></h3>
<p>Reads a line of input from the socket. If the input is a valid status line, the HTTP version (1 or 1.1), status code and reason description (if applicable) is returned. <code>:read_status_line()</code> yields until a &quot;&quot; terminated chunk is received, or <code>timeout</code> is exceeded. If the socket could not be read, returns <code>nil</code>, an error message and an error number.</p>
</section>
<section id="http.h1_connection:read_header" class="level3">
<h3><code>h1_connection:read_header(timeout)</code> <!-- --></h3>
<p>Reads a CRLF terminated HTTP header from the socket and returns the header key and value. This function will yield until a MIME compliant header item is received or until <code>timeout</code> is exceeded. If the header could not be read, the function returns <code>nil</code> an error and an error message.</p>
</section>
<section id="http.h1_connection:read_headers_done" class="level3">
<h3><code>h1_connection:read_headers_done(timeout)</code> <!-- --></h3>
<p>Checks for an empty line, which indicates the end of the HTTP headers. Returns <code>true</code> if an empty line is received. Any other value is pushed back on the socket receive buffer (unget) and the function returns <code>false</code>. This function will yield waiting for input from the socket or until <code>timeout</code> is exceeded. Returns <code>nil</code>, an error and an error message if the socket cannot be read.</p>
</section>
<section id="http.h1_connection:read_body_by_length" class="level3">
<h3><code>h1_connection:read_body_by_length(len, timeout)</code> <!-- --></h3>
<p>Get <code>len</code> number of bytes from the socket. Use a negative number for <em>up to</em> that number of bytes. This function will yield and wait on the socket if length of the buffered body is less than <code>len</code>. Asserts if len is not a number.</p>
</section>
<section id="http.h1_connection:read_body_till_close" class="level3">
<h3><code>h1_connection:read_body_till_close(timeout)</code> <!-- --></h3>
<p>Reads the entire request body. This function will yield until the body is complete or <code>timeout</code> is expired. If the read fails the function returns <code>nil</code>, an error message and an error number.</p>
</section>
<section id="http.h1_connection:read_body_chunk" class="level3">
<h3><code>h1_connection:read_body_chunk(timeout)</code> <!-- --></h3>
<p>Reads the next available line of data from the request and returns the chunk and any chunk extensions. This function will yield until chunk size is received or <code>timeout</code> is exceeded. If the chunk size is indicated as <code>0</code> then <code>false</code> and any chunk extensions are returned. Returns <code>nil</code>, an error message and an error number if there was an error reading reading the chunk header or the socket.</p>
</section>
<section id="http.h1_connection:write_request_line" class="level3">
<h3><code>h1_connection:write_request_line(method, path, httpversion, timeout)</code> <!-- --></h3>
<p>Writes the opening HTTP 1.x request line for a new request to the socket buffer. Yields until success or <code>timeout</code>. If the write fails, returns <code>nil</code>, an error message and an error number.</p>
<p><em>Note the request line will not be flushed to the remote server until</em> <a href="#http.h1_connection:write_headers_done"><code>write_headers_done</code></a> <em>is called.</em></p>
</section>
<section id="http.h1_connection:write_status_line" class="level3">
<h3><code>h1_connection:write_status_line(httpversion, status_code, reason_phrase, timeout)</code> <!-- --></h3>
<p>Writes an HTTP status line to the socket buffer. Yields until success or <code>timeout</code>. If the write fails, the function returns <code>nil</code>, an error message and an error number.</p>
<p><em>Note the status line will not be flushed to the remote server until</em> <a href="#http.h1_connection:write_headers_done"><code>write_headers_done</code></a> <em>is called.</em></p>
</section>
<section id="http.h1_connection:write_header" class="level3">
<h3><code>h1_connection:write_header(k, v, timeout)</code> <!-- --></h3>
<p>Writes a header item to the socket buffer as a <code>key:value</code> string. Yields until success or <code>timeout</code>. Returns <code>nil</code>, an error message and an error if the write fails.</p>
<p><em>Note the header item will not be flushed to the remote server until</em> <a href="#http.h1_connection:write_headers_done"><code>write_headers_done</code></a> <em>is called.</em></p>
</section>
<section id="http.h1_connection:write_headers_done" class="level3">
<h3><code>h1_connection:write_headers_done(timeout)</code> <!-- --></h3>
<p>Terminates a header block by writing a blank line (<code>&quot;\r\n&quot;</code>) to the socket. This function will flush all outstanding data in the socket output buffer. Yields until success or <code>timeout</code>. Returns <code>nil</code>, an error message and an error if the write fails.</p>
</section>
<section id="http.h1_connection:write_body_chunk" class="level3">
<h3><code>h1_connection:write_body_chunk(chunk, chunk_ext, timeout)</code> <!-- --></h3>
<p>Writes a chunk of data to the socket. <code>chunk_ext</code> must be <code>nil</code> as chunk extensions are not supported. Will yield until complete or <code>timeout</code> is exceeded. Returns true on success. Returns <code>nil</code>, an error message and an error number if the write fails.</p>
<p><em>Note that <code>chunk</code> will not be flushed to the remote server until</em> <a href="#http.h1_connection:write_body_last_chunk"><code>write_body_last_chunk</code></a> <em>is called.</em></p>
</section>
<section id="http.h1_connection:write_body_last_chunk" class="level3">
<h3><code>h1_connection:write_body_last_chunk(chunk_ext, timeout)</code> <!-- --></h3>
<p>Writes the chunked body terminator <code>&quot;0\r\n&quot;</code> to the socket and flushes the socket output buffer. <code>chunk_ext</code> must be <code>nil</code> as chunk extensions are not supported. Will yield until complete or <code>timeout</code> is exceeded. Returns <code>nil</code>, an error message and an error number if the write fails.</p>
</section>
<section id="http.h1_connection:write_body_plain" class="level3">
<h3><code>h1_connection:write_body_plain(body, timeout)</code> <!-- --></h3>
<p>Writes the contents of <code>body</code> to the socket and flushes the socket output buffer immediately. Yields until success or <code>timeout</code> is exceeded. Returns <code>nil</code>, an error message and an error number if the write fails.</p>
</section>
</section>
<section id="http.h1_reason_phrases" class="level2">
<h2>http.h1_reason_phrases</h2>
<p>A table mapping from status codes (as strings) to reason phrases for HTTP 1. Any unknown status codes return <code>&quot;Unassigned&quot;</code></p>
<section id="http.h1_reason_phrases-example" class="level3">
<h3>Example</h3>
<div class="sourceCode"><pre class="sourceCode lua"><code class="sourceCode lua"><span class="kw">local</span> reason_phrases <span class="ot">=</span> <span class="fu">require</span> <span class="st">&quot;http.h1_reason_phrases&quot;</span>
<span class="fu">print</span><span class="ot">(</span>reason_phrases<span class="ot">[</span><span class="st">&quot;200&quot;</span><span class="ot">])</span> <span class="do">--&gt; &quot;OK&quot;</span>
<span class="fu">print</span><span class="ot">(</span>reason_phrases<span class="ot">[</span><span class="st">&quot;342&quot;</span><span class="ot">])</span> <span class="do">--&gt; &quot;Unassigned&quot;</span></code></pre></div>
</section>
</section>
<section id="http.h1_stream" class="level2">
<h2>http.h1_stream</h2>
<p>An h1_stream represents an HTTP 1.0 or 1.1 request/response. The module follows the <a href="#stream"><em>stream</em></a> interface and the methods from <a href="#http.stream_common"><em>http.stream_common</em></a>, as well as the following HTTP 1 specific functions:</p>
<section id="http.h1_stream:set_state" class="level3">
<h3><code>h1_stream:set_state(new)</code> <!-- --></h3>
<p>Sets h1_stream.state if <code>new</code> is one of the following valid states:</p>
<p><code>lua valid_states = {     [&quot;idle&quot;] = 1; -- initial     [&quot;open&quot;] = 2; -- have sent or received headers; haven't sent body yet     [&quot;half closed (local)&quot;] = 3; -- have sent whole body     [&quot;half closed (remote)&quot;] = 3; -- have received whole body     [&quot;closed&quot;] = 4; -- complete }</code></p>
<p>Asserts if <code>new</code> is not a valid value.</p>
</section>
<section id="http.h1_stream:read_headers" class="level3">
<h3><code>h1_stream:read_headers(timeout)</code> <!-- --></h3>
<p>Returns a table containing the request line and all HTTP headers as key value pairs.</p>
</section>
</section>
<section id="http.h2_connection" class="level2">
<h2>http.h2_connection</h2>
<p>An HTTP 2 connection can have multiple streams actively transmitting data at once, hence an <em>http.h2_connection</em> acts much like a scheduler.</p>
<section id="http.h2_connection.new" class="level3">
<h3><code>new(socket, conn_type, settings)</code> <!-- --></h3>
</section>
<section id="http.h2_connection.version" class="level3">
<h3><code>h2_connection.version</code> <!-- --></h3>
<p>Contains the value of the HTTP 2 version number for the connection. Currently will hold the value of <code>2</code></p>
</section>
<section id="http.h2_connection:pollfd" class="level3">
<h3><code>h2_connection:pollfd()</code> <!-- --></h3>
</section>
<section id="http.h2_connection:events" class="level3">
<h3><code>h2_connection:events()</code> <!-- --></h3>
</section>
<section id="http.h2_connection:timeout" class="level3">
<h3><code>h2_connection:timeout()</code> <!-- --></h3>
</section>
<section id="http.h2_connection:empty" class="level3">
<h3><code>h2_connection:empty()</code> <!-- --></h3>
</section>
<section id="http.h2_connection:step" class="level3">
<h3><code>h2_connection:step(timeout)</code> <!-- --></h3>
</section>
<section id="http.h2_connection:loop" class="level3">
<h3><code>h2_connection:loop(timeout)</code> <!-- --></h3>
</section>
<section id="http.h2_connection:connect" class="level3">
<h3><code>h2_connection:connect(timeout)</code> <!-- --></h3>
<p>See <a href="#connection:connect"><code>connection:connect(timeout)</code></a></p>
</section>
<section id="http.h2_connection:checktls" class="level3">
<h3><code>h2_connection:checktls()</code> <!-- --></h3>
<p>See <a href="#connection:checktls"><code>connection:checktls()</code></a></p>
</section>
<section id="http.h2_connection:localname" class="level3">
<h3><code>h2_connection:localname()</code> <!-- --></h3>
<p>See <a href="#connection:localname"><code>connection:localname()</code></a></p>
</section>
<section id="http.h2_connection:peername" class="level3">
<h3><code>h2_connection:peername()</code> <!-- --></h3>
<p>See <a href="#connection:peername"><code>connection:peername()</code></a></p>
</section>
<section id="http.h2_connection:shutdown" class="level3">
<h3><code>h2_connection:shutdown()</code> <!-- --></h3>
<p>See <a href="#connection:shutdown"><code>connection:shutdown()</code></a></p>
</section>
<section id="http.h2_connection:close" class="level3">
<h3><code>h2_connection:close()</code> <!-- --></h3>
<p>See <a href="#connection:close"><code>connection:close()</code></a></p>
</section>
<section id="http.h2_connection:new_stream" class="level3">
<h3><code>h2_connection:new_stream(id)</code> <!-- --></h3>
<p><code>id</code> (optional) is the stream id to assign the new stream. For client initiated streams, this will be the next free odd numbered stream.<br />
For server initiated streams, this will be the next free even numbered stream.</p>
<p>See <a href="#connection:new_stream"><code>connection:new_stream()</code></a> for more information.</p>
</section>
<section id="http.h2_connection:get_next_incoming_stream" class="level3">
<h3><code>h2_connection:get_next_incoming_stream(timeout)</code> <!-- --></h3>
<p>See <a href="#connection:get_next_incoming_stream"><code>connection:get_next_incoming_stream()</code></a></p>
</section>
<section id="http.h2_connection:read_http2_frame" class="level3">
<h3><code>h2_connection:read_http2_frame(timeout)</code> <!-- --></h3>
</section>
<section id="http.h2_connection:write_http2_frame" class="level3">
<h3><code>h2_connection:write_http2_frame(typ, flags, streamid, payload, timeout)</code> <!-- --></h3>
</section>
<section id="http.h2_connection:ping" class="level3">
<h3><code>h2_connection:ping(timeout)</code> <!-- --></h3>
</section>
<section id="http.h2_connection:write_window_update" class="level3">
<h3><code>h2_connection:write_window_update(inc, timeout)</code> <!-- --></h3>
</section>
<section id="http.h2_connection:write_goaway_frame" class="level3">
<h3><code>h2_connection:write_goaway_frame(last_stream_id, err_code, debug_msg)</code> <!-- --></h3>
</section>
<section id="http.h2_connection:set_peer_settings" class="level3">
<h3><code>h2_connection:set_peer_settings(peer_settings)</code> <!-- --></h3>
</section>
<section id="http.h2_connection:ack_settings" class="level3">
<h3><code>h2_connection:ack_settings()</code> <!-- --></h3>
</section>
<section id="http.h2_connection:settings" class="level3">
<h3><code>h2_connection:settings(tbl, timeout)</code> <!-- --></h3>
</section>
</section>
<section id="http.h2_error" class="level2">
<h2>http.h2_error</h2>
<p>A type of error object that encapsulates HTTP 2 error information. An <code>http.h2_error</code> object has fields:</p>
<ul>
<li><code>name</code>: The error name: a short identifier for this error</li>
<li><code>code</code>: The error code</li>
<li><code>description</code>: The description of the error code</li>
<li><code>message</code>: An error message</li>
<li><code>traceback</code>: A traceback taken at the point the error was thrown</li>
<li><code>stream_error</code>: A boolean that indicates if this is a stream level or protocol level error</li>
</ul>
<section id="http.h2_error.errors" class="level3">
<h3><code>errors</code> <!-- --></h3>
<p>A table containing errors <a href="https://http2.github.io/http2-spec/#iana-errors">as defined by the HTTP 2 specification</a>. It can be indexed by error name (e.g. <code>errors.PROTOCOL_ERROR</code>) or numeric code (e.g. <code>errors[0x1]</code>).</p>
</section>
<section id="http.h2_error.is" class="level3">
<h3><code>is(ob)</code> <!-- --></h3>
<p>Returns a boolean indicating if the object <code>ob</code> is an <code>http.h2_error</code> object</p>
</section>
<section id="http.h2_error:new" class="level3">
<h3><code>h2_error:new(ob)</code> <!-- --></h3>
<p>Creates a new error object from the passed table. The table should have the form of an error object i.e. with fields <code>name</code>, <code>code</code>, <code>message</code>, <code>traceback</code>, etc.</p>
<p>Fields <code>name</code>, <code>code</code> and <code>description</code> are inherited from the parent <code>h2_error</code> object if not specified.</p>
<p><code>stream_error</code> defaults to <code>false</code>.</p>
</section>
<section id="http.h2_error:new_traceback" class="level3">
<h3><code>h2_error:new_traceback(message, stream_error, lvl)</code> <!-- --></h3>
<p>Creates a new error object, recording a traceback from the current thread.</p>
</section>
<section id="http.h2_error:error" class="level3">
<h3><code>h2_error:error(message, stream_error, lvl)</code> <!-- --></h3>
<p>Creates and throws a new error.</p>
</section>
<section id="http.h2_error:assert" class="level3">
<h3><code>h2_error:assert(cond, ...)</code> <!-- --></h3>
<p>If <code>cond</code> is truthy, returns <code>cond, ...</code></p>
<p>If <code>cond</code> is falsy (i.e. <code>false</code> or <code>nil</code>), throws an error with the first element of <code>...</code> as the <code>message</code>.</p>
</section>
</section>
<section id="http.h2_stream" class="level2">
<h2>http.h2_stream</h2>
<p>In addition to following the <a href="#stream"><em>stream</em></a> interface and the methods from <a href="#http.stream_common">http.stream_common</a>, an <code>http.h2_stream</code> has the following methods:</p>
<section id="http.h2_stream:set_state" class="level3">
<h3><code>h2_stream:set_state(new)</code> <!-- --></h3>
</section>
<section id="http.h2_stream:reprioritise" class="level3">
<h3><code>h2_stream:reprioritise(child, exclusive)</code> <!-- --></h3>
</section>
<section id="http.h2_stream:write_http2_frame" class="level3">
<h3><code>h2_stream:write_http2_frame(typ, flags, payload, timeout)</code> <!-- --></h3>
</section>
<section id="http.h2_stream:write_data_frame" class="level3">
<h3><code>h2_stream:write_data_frame(payload, end_stream, padded, timeout)</code> <!-- --></h3>
</section>
<section id="http.h2_stream:write_headers_frame" class="level3">
<h3><code>h2_stream:write_headers_frame(payload, end_stream, end_headers, padded, exclusive, stream_dep, weight, timeout)</code> <!-- --></h3>
</section>
<section id="http.h2_stream:write_priority_frame" class="level3">
<h3><code>h2_stream:write_priority_frame(exclusive, stream_dep, weight, timeout)</code> <!-- --></h3>
</section>
<section id="http.h2_stream:write_rst_stream" class="level3">
<h3><code>h2_stream:write_rst_stream(err_code, timeout)</code> <!-- --></h3>
</section>
<section id="http.h2_stream:write_settings_frame" class="level3">
<h3><code>h2_stream:write_settings_frame(ACK, settings, timeout)</code> <!-- --></h3>
</section>
<section id="http.h2_stream:write_push_promise_frame" class="level3">
<h3><code>h2_stream:write_push_promise_frame(promised_stream_id, payload, end_headers, padded, timeout)</code> <!-- --></h3>
</section>
<section id="http.h2_stream:push_promise" class="level3">
<h3><code>h2_stream:push_promise(headers, timeout)</code> <!-- --></h3>
<p>Pushes a new promise to the client.</p>
<p>Returns the new stream as a <a href="#http.h2_stream">h2_stream</a>.</p>
</section>
<section id="http.h2_stream:write_ping_frame" class="level3">
<h3><code>h2_stream:write_ping_frame(ACK, payload, timeout)</code> <!-- --></h3>
</section>
<section id="http.h2_stream:write_goaway_frame" class="level3">
<h3><code>h2_stream:write_goaway_frame(last_streamid, err_code, debug_msg, timeout)</code> <!-- --></h3>
</section>
<section id="http.h2_stream:write_window_update_frame" class="level3">
<h3><code>h2_stream:write_window_update_frame(inc, timeout)</code> <!-- --></h3>
</section>
<section id="http.h2_stream:write_window_update" class="level3">
<h3><code>h2_stream:write_window_update(inc)</code> <!-- --></h3>
</section>
<section id="http.h2_stream:read_continuation" class="level3">
<h3><code>h2_stream:read_continuation(timeout)</code> <!-- --></h3>
<p>Reads a continuation frame from the underlying connection. If the next frame is not a continuation frame then returns an error.</p>
<p>On success returns a boolean indicating if this was the last continuation frame and the frame payload.</p>
</section>
<section id="http.h2_stream:write_continuation_frame" class="level3">
<h3><code>h2_stream:write_continuation_frame(payload, end_headers, timeout)</code> <!-- --></h3>
</section>
</section>
<section id="http.headers" class="level2">
<h2>http.headers</h2>
<p>An ordered list of header fields. Each field has a <em>name</em>, a <em>value</em> and a <em>never_index</em> flag that indicates if the header field is potentially sensitive data.</p>
<p>Each headers object has an index by field name to efficiently retrieve values by key. Keep in mind that there can be multiple values for a given field name. (e.g. an HTTP server may send two <code>Set-Cookie</code> headers).</p>
<section id="http.headers.new" class="level3">
<h3><code>new()</code> <!-- --></h3>
<p>Creates and returns a new headers object.</p>
</section>
<section id="http.headers:len" class="level3">
<h3><code>headers:len()</code> <!-- --></h3>
<p>Returns the number of headers.</p>
<p>Also available as <code>#headers</code> in Lua 5.2+.</p>
</section>
<section id="http.headers:clone" class="level3">
<h3><code>headers:clone()</code> <!-- --></h3>
<p>Creates and returns a clone of the headers object.</p>
</section>
<section id="http.headers:append" class="level3">
<h3><code>headers:append(name, value, never_index)</code> <!-- --></h3>
<p>Append a header.</p>
<ul>
<li><code>name</code> is the header field name. Lower case is the convention. It will not be validated at this time.</li>
<li><code>value</code> is the header field value. It will not be validated at this time.</li>
<li><code>never_index</code> is an optional boolean that indicates if the <code>value</code> should be considered secret. Defaults to true for header fields: authorization, proxy-authorization, cookie and set-cookie.</li>
</ul>
</section>
<section id="http.headers:each" class="level3">
<h3><code>headers:each()</code> <!-- --></h3>
<p>An iterator over all headers that emits <code>name, value, never_index</code>.</p>
<section id="example" class="level4">
<h4>Example</h4>
<div class="sourceCode"><pre class="sourceCode lua"><code class="sourceCode lua"><span class="kw">local</span> http_headers <span class="ot">=</span> <span class="fu">require</span> <span class="st">&quot;http.headers&quot;</span>
<span class="kw">local</span> myheaders <span class="ot">=</span> http_headers<span class="ot">.</span>new<span class="ot">()</span>
myheaders:append<span class="ot">(</span><span class="st">&quot;:status&quot;</span><span class="ot">,</span> <span class="st">&quot;200&quot;</span><span class="ot">)</span>
myheaders:append<span class="ot">(</span><span class="st">&quot;set-cookie&quot;</span><span class="ot">,</span> <span class="st">&quot;foo=bar&quot;</span><span class="ot">)</span>
myheaders:append<span class="ot">(</span><span class="st">&quot;connection&quot;</span><span class="ot">,</span> <span class="st">&quot;close&quot;</span><span class="ot">)</span>
myheaders:append<span class="ot">(</span><span class="st">&quot;set-cookie&quot;</span><span class="ot">,</span> <span class="st">&quot;baz=qux&quot;</span><span class="ot">)</span>
<span class="kw">for</span> name<span class="ot">,</span> value<span class="ot">,</span> never_index <span class="kw">in</span> myheaders:each<span class="ot">()</span> <span class="kw">do</span>
    <span class="fu">print</span><span class="ot">(</span>name<span class="ot">,</span> value<span class="ot">,</span> never_index<span class="ot">)</span>
<span class="kw">end</span>
<span class="do">--[[ prints:</span>
<span class="do">&quot;:status&quot;, &quot;200&quot;, false</span>
<span class="do">&quot;set-cookie&quot;, &quot;foo=bar&quot;, true</span>
<span class="do">&quot;connection&quot;, &quot;close&quot;, false</span>
<span class="do">&quot;set-cookie&quot;, &quot;baz=qux&quot;, true</span>
<span class="do">]]</span></code></pre></div>
</section>
</section>
<section id="http.headers:has" class="level3">
<h3><code>headers:has(name)</code> <!-- --></h3>
<p>Returns a boolean indicating if the headers object has a field with the given <code>name</code>.</p>
</section>
<section id="http.headers:delete" class="level3">
<h3><code>headers:delete(name)</code> <!-- --></h3>
<p>Removes all occurrences of a field name from the headers object.</p>
</section>
<section id="http.headers:geti" class="level3">
<h3><code>headers:geti(i)</code> <!-- --></h3>
<p>Return the <code>i</code>-th header as <code>name, value, never_index</code></p>
</section>
<section id="http.headers:get_as_sequence" class="level3">
<h3><code>headers:get_as_sequence(name)</code> <!-- --></h3>
<p>Returns all headers with the given name in a table. The table will contain a field <code>.n</code> with the number of elements.</p>
<section id="example-1" class="level4">
<h4>Example</h4>
<div class="sourceCode"><pre class="sourceCode lua"><code class="sourceCode lua"><span class="kw">local</span> http_headers <span class="ot">=</span> <span class="fu">require</span> <span class="st">&quot;http.headers&quot;</span>
<span class="kw">local</span> myheaders <span class="ot">=</span> http_headers<span class="ot">.</span>new<span class="ot">()</span>
myheaders:append<span class="ot">(</span><span class="st">&quot;:status&quot;</span><span class="ot">,</span> <span class="st">&quot;200&quot;</span><span class="ot">)</span>
myheaders:append<span class="ot">(</span><span class="st">&quot;set-cookie&quot;</span><span class="ot">,</span> <span class="st">&quot;foo=bar&quot;</span><span class="ot">)</span>
myheaders:append<span class="ot">(</span><span class="st">&quot;connection&quot;</span><span class="ot">,</span> <span class="st">&quot;close&quot;</span><span class="ot">)</span>
myheaders:append<span class="ot">(</span><span class="st">&quot;set-cookie&quot;</span><span class="ot">,</span> <span class="st">&quot;baz=qux&quot;</span><span class="ot">)</span>
<span class="kw">local</span> mysequence <span class="ot">=</span> myheaders:get_as_sequence<span class="ot">(</span><span class="st">&quot;set-cookie&quot;</span><span class="ot">)</span>
<span class="do">--[[ mysequence will be:</span>
<span class="do">{n = 2; &quot;foo=bar&quot;; &quot;baz=qux&quot;}</span>
<span class="do">]]</span></code></pre></div>
</section>
</section>
<section id="http.headers:get" class="level3">
<h3><code>headers:get(name)</code> <!-- --></h3>
<p>Returns all headers with the given name as multiple return values.</p>
</section>
<section id="http.headers:get_comma_separated" class="level3">
<h3><code>headers:get_comma_separated(name)</code> <!-- --></h3>
<p>Returns all headers with the given name as items in a comma separated string.</p>
</section>
<section id="http.headers:modifyi" class="level3">
<h3><code>headers:modifyi(i, value, never_index)</code> <!-- --></h3>
<p>Change the <code>i</code>-th's header to a new <code>value</code> and <code>never_index</code>.</p>
</section>
<section id="http.headers:upsert" class="level3">
<h3><code>headers:upsert(name, value, never_index)</code> <!-- --></h3>
<p>If a header with the given <code>name</code> already exists, replace it. If not, <a href="#http.headers:append"><code>append</code></a> it to the list of headers.</p>
<p>Cannot be used when a header <code>name</code> already has multiple values.</p>
</section>
<section id="http.headers:sort" class="level3">
<h3><code>headers:sort()</code> <!-- --></h3>
<p>Sort the list of headers by their field name, ordering those starting with <code>:</code> first. If <code>name</code>s are equal then sort by <code>value</code>, then by <code>never_index</code>.</p>
</section>
<section id="http.headers:dump" class="level3">
<h3><code>headers:dump(file, prefix)</code> <!-- --></h3>
<p>Print the headers list to the given file, one per line. If <code>file</code> is not given, then print to <code>stderr</code>. <code>prefix</code> is prefixed to each line.</p>
</section>
</section>
<section id="http.hpack" class="level2">
<h2>http.hpack</h2>
<section id="http.hpack.new" class="level3">
<h3><code>new(SETTINGS_HEADER_TABLE_SIZE)</code> <!-- --></h3>
</section>
<section id="http.hpack:append_data" class="level3">
<h3><code>hpack_context:append_data(val)</code> <!-- --></h3>
</section>
<section id="http.hpack:render_data" class="level3">
<h3><code>hpack_context:render_data()</code> <!-- --></h3>
</section>
<section id="http.hpack:clear_data" class="level3">
<h3><code>hpack_context:clear_data()</code> <!-- --></h3>
</section>
<section id="http.hpack:evict_from_dynamic_table" class="level3">
<h3><code>hpack_context:evict_from_dynamic_table()</code> <!-- --></h3>
</section>
<section id="http.hpack:dynamic_table_tostring" class="level3">
<h3><code>hpack_context:dynamic_table_tostring()</code> <!-- --></h3>
</section>
<section id="http.hpack:set_max_dynamic_table_size" class="level3">
<h3><code>hpack_context:set_max_dynamic_table_size(SETTINGS_HEADER_TABLE_SIZE)</code> <!-- --></h3>
</section>
<section id="http.hpack:encode_max_size" class="level3">
<h3><code>hpack_context:encode_max_size(val)</code> <!-- --></h3>
</section>
<section id="http.hpack:resize_dynamic_table" class="level3">
<h3><code>hpack_context:resize_dynamic_table(new_size)</code> <!-- --></h3>
</section>
<section id="http.hpack:add_to_dynamic_table" class="level3">
<h3><code>hpack_context:add_to_dynamic_table(name, value, k)</code> <!-- --></h3>
</section>
<section id="http.hpack:dynamic_table_id_to_index" class="level3">
<h3><code>hpack_context:dynamic_table_id_to_index(id)</code> <!-- --></h3>
</section>
<section id="http.hpack:lookup_pair_index" class="level3">
<h3><code>hpack_context:lookup_pair_index(k)</code> <!-- --></h3>
</section>
<section id="http.hpack:lookup_name_index" class="level3">
<h3><code>hpack_context:lookup_name_index(name)</code> <!-- --></h3>
</section>
<section id="http.hpack:lookup_index" class="level3">
<h3><code>hpack_context:lookup_index(index, allow_single)</code> <!-- --></h3>
</section>
<section id="http.hpack:add_header_indexed" class="level3">
<h3><code>hpack_context:add_header_indexed(name, value, huffman)</code> <!-- --></h3>
</section>
<section id="http.hpack:add_header_never_indexed" class="level3">
<h3><code>hpack_context:add_header_never_indexed(name, value, huffman)</code> <!-- --></h3>
</section>
<section id="http.hpack:encode_headers" class="level3">
<h3><code>hpack_context:encode_headers(headers)</code> <!-- --></h3>
</section>
<section id="http.hpack:decode_headers" class="level3">
<h3><code>hpack_context:decode_headers(payload, header_list, pos)</code> <!-- --></h3>
</section>
</section>
<section id="http.hsts" class="level2">
<h2>http.hsts</h2>
<p>Data structures useful for HSTS (HTTP Strict Transport Security)</p>
<section id="http.hsts.new_store" class="level3">
<h3><code>new_store()</code> <!-- --></h3>
<p>Creates and returns a new HSTS store.</p>
</section>
<section id="http.hsts:clone" class="level3">
<h3><code>hsts_store:clone()</code> <!-- --></h3>
<p>Creates and returns a copy of a store.</p>
</section>
<section id="http.hsts:store" class="level3">
<h3><code>hsts_store:store(host, directives)</code> <!-- --></h3>
<p>Add new directives to the store about the given <code>host</code>. <code>directives</code> should be a table of directives, which <em>must</em> include the key <code>&quot;max-age&quot;</code>.</p>
</section>
<section id="http.hsts:check" class="level3">
<h3><code>hsts_store:check(host)</code> <!-- --></h3>
<p>Returns a boolean indicating if the given <code>host</code> is a known HSTS host.</p>
</section>
<section id="http.hsts:clean" class="level3">
<h3><code>hsts_store:clean()</code> <!-- --></h3>
<p>Removes expired entries from the store.</p>
</section>
</section>
<section id="http.proxies" class="level2">
<h2>http.proxies</h2>
<section id="http.proxies.new" class="level3">
<h3><code>new()</code> <!-- --></h3>
<p>Returns an empty 'proxies' object</p>
</section>
<section id="http.proxies:update" class="level3">
<h3><code>proxies:update(getenv)</code> <!-- --></h3>
<p><code>getenv</code> defaults to <a href="http://www.lua.org/manual/5.3/manual.html#pdf-os.getenv"><code>os.getenv</code></a></p>
<p>Reads environmental variables that are used to control if requests go through a proxy.</p>
<p>Returns <code>proxies</code>.</p>
</section>
<section id="http.proxies:choose" class="level3">
<h3><code>proxies:choose(scheme, host)</code> <!-- --></h3>
<p>Returns the proxy to use for the given <code>scheme</code> and <code>host</code> as a URI.</p>
</section>
</section>
<section id="http.request" class="level2">
<h2>http.request</h2>
<p>The http.request module encapsulates all the functionality required to retrieve an HTTP document from a server.</p>
<section id="http.request.new_from_uri" class="level3">
<h3><code>new_from_uri(uri)</code> <!-- --></h3>
<p>Creates a new <code>http.request</code> object from the given URI.</p>
</section>
<section id="http.request.new_connect" class="level3">
<h3><code>new_connect(uri, connect_authority)</code> <!-- --></h3>
<p>Creates a new <code>http.request</code> object from the given URI that will perform a <em>CONNECT</em> request.</p>
</section>
<section id="http.request.host" class="level3">
<h3><code>request.host</code> <!-- --></h3>
<p>The host this request should be sent to.</p>
</section>
<section id="http.request.port" class="level3">
<h3><code>request.port</code> <!-- --></h3>
<p>The port this request should be sent to.</p>
</section>
<section id="http.request.tls" class="level3">
<h3><code>request.tls</code> <!-- --></h3>
<p>A boolean indicating if TLS should be used.</p>
</section>
<section id="http.request.ctx" class="level3">
<h3><code>request.ctx</code> <!-- --></h3>
<p>An alternative <code>SSL_CTX*</code> to use. If not specified, uses the default TLS settings (see <a href="#http.tls"><em>http.tls</em></a> for information).</p>
</section>
<section id="http.request.sendname" class="level3">
<h3><code>request.sendname</code> <!-- --></h3>
<p>The TLS SNI host name used.</p>
</section>
<section id="http.request.version" class="level3">
<h3><code>request.version</code> <!-- --></h3>
<p>The HTTP version to use; leave as <code>nil</code> to auto-select.</p>
</section>
<section id="http.request.proxy" class="level3">
<h3><code>request.proxy</code> <!-- --></h3>
<p>Specifies the a proxy that the request will be made through. The value should be a URI or <code>false</code> to turn off proxying for the request.</p>
</section>
<section id="http.request.headers" class="level3">
<h3><code>request.headers</code> <!-- --></h3>
<p>A <a href="#http.headers"><em>http.headers</em></a> object of headers that will be sent in the request.</p>
</section>
<section id="http.request.follow_redirects" class="level3">
<h3><code>request.follow_redirects</code> <!-- --></h3>
<p>Boolean indicating if <code>:go()</code> should follow redirects. Defaults to <code>true</code>.</p>
</section>
<section id="http.request.expect_100_timeout" class="level3">
<h3><code>request.expect_100_timeout</code> <!-- --></h3>
<p>Number of seconds to wait for a 100 Continue response before proceeding to send a request body. Defaults to <code>1</code>.</p>
</section>
<section id="http.request.max_redirects" class="level3">
<h3><code>request.max_redirects</code> <!-- --></h3>
<p>Maximum number of redirects to follow before giving up. Defaults to <code>5</code>. Set to <code>math.huge</code> to not give up.</p>
</section>
<section id="http.request.post301" class="level3">
<h3><code>request.post301</code> <!-- --></h3>
<p>Respect RFC 2616 Section 10.3.2 and <strong>don't</strong> convert POST requests into body-less GET requests when following a 301 redirect. The non-RFC behaviour is ubiquitous in web browsers and assumed by servers. Modern HTTP endpoints send status code 308 to indicate that they don't want the method to be changed. Defaults to <code>false</code>.</p>
</section>
<section id="http.request.post302" class="level3">
<h3><code>request.post302</code> <!-- --></h3>
<p>Respect RFC 2616 Section 10.3.3 and <strong>don't</strong> convert POST requests into body-less GET requests when following a 302 redirect. The non-RFC behaviour is ubiquitous in web browsers and assumed by servers. Modern HTTP endpoints send status code 307 to indicate that they don't want the method to be changed. Defaults to <code>false</code>.</p>
</section>
<section id="http.request:clone" class="level3">
<h3><code>request:clone()</code> <!-- --></h3>
<p>Creates and returns a clone of the request.</p>
<p>The clone has its own deep copies of the <a href="#http.request.headers"><code>.headers</code></a> and <a href="#http.request.h2_settings"><code>.h2_settings</code></a> fields.</p>
<p>The <a href="#http.request.tls"><code>.tls</code></a> and <a href="#http.request.body"><code>.body</code></a> fields are shallow copied from the original request.</p>
</section>
<section id="http.request:handle_redirect" class="level3">
<h3><code>request:handle_redirect(headers)</code> <!-- --></h3>
<p>Process a redirect.</p>
<p><code>headers</code> should be response headers for a redirect.</p>
<p>Returns a new <code>request</code> object that will fetch from new location.</p>
</section>
<section id="http.request:to_uri" class="level3">
<h3><code>request:to_uri(with_userinfo)</code> <!-- --></h3>
<p>Returns a URI for the request.</p>
<p>If <code>with_userinfo</code> is <code>true</code> and the request has an <code>authorization</code> header (or <code>proxy-authorization</code> for a CONNECT request), the returned URI will contain a userinfo component.</p>
</section>
<section id="http.request:set_body" class="level3">
<h3><code>request:set_body(body)</code> <!-- --></h3>
<p>Allows setting a request body. <code>body</code> may be a string, function or lua file object.</p>
<ul>
<li>If <code>body</code> is a string it will be sent as given.</li>
<li>If <code>body</code> is a function, it will be called repeatedly like an iterator. It should return chunks of the request body as a string or <code>nil</code> if done.</li>
<li>If <code>body</code> is a lua file object, it will be <a href="http://www.lua.org/manual/5.3/manual.html#pdf-file:seek"><code>:seek</code>'d</a> to the start, then sent as a body. Any errors encountered during file operations <strong>will be thrown</strong>.</li>
</ul>
</section>
<section id="http.request:timeout" class="level3">
<h3><code>request:go(timeout)</code> <!-- --></h3>
<p>Performs the request.</p>
<p>The request object is <strong>not</strong> invalidated; and can be reused for a new request. On success, returns the response <a href="#http.headers"><em>headers</em></a> and a <a href="#stream"><em>stream</em></a>.</p>
</section>
</section>
<section id="http.server" class="level2">
<h2>http.server</h2>
<p>This interface is <strong>unstable</strong>.</p>
<section id="http.server.connect" class="level3">
<h3><code>listen(options)</code> <!-- --></h3>
</section>
<section id="http.server:onerror" class="level3">
<h3><code>server:onerror(new_handler)</code> <!-- --></h3>
</section>
<section id="http.server:listen" class="level3">
<h3><code>server:listen(timeout)</code> <!-- --></h3>
</section>
<section id="http.server:localname" class="level3">
<h3><code>server:localname()</code> <!-- --></h3>
</section>
<section id="http.server:pause" class="level3">
<h3><code>server:pause()</code> <!-- --></h3>
<p>Cause the server loop to stop processing new clients until <a href="#http.server:resume"><code>:resume</code></a> is called.</p>
</section>
<section id="http.server:resume" class="level3">
<h3><code>server:resume()</code> <!-- --></h3>
</section>
<section id="http.server:close" class="level3">
<h3><code>server:close()</code> <!-- --></h3>
</section>
<section id="http.server:pollfd" class="level3">
<h3><code>server:pollfd()</code> <!-- --></h3>
</section>
<section id="http.server:events" class="level3">
<h3><code>server:events()</code> <!-- --></h3>
</section>
<section id="http.server:timeout" class="level3">
<h3><code>server:timeout()</code> <!-- --></h3>
</section>
<section id="http.server:empty" class="level3">
<h3><code>server:empty()</code> <!-- --></h3>
</section>
<section id="http.server:step" class="level3">
<h3><code>server:step()</code> <!-- --></h3>
</section>
<section id="http.server:loop" class="level3">
<h3><code>server:loop()</code> <!-- --></h3>
</section>
<section id="http.server:add_socket" class="level3">
<h3><code>server:add_socket(socket)</code> <!-- --></h3>
</section>
</section>
<section id="http.socks" class="level2">
<h2>http.socks</h2>
<p>Implements a subset of the SOCKS proxy protocol.</p>
<section id="http.socks.connect" class="level3">
<h3><code>connect(uri)</code> <!-- --></h3>
<ul>
<li><code>uri</code> is a string with the address of the SOCKS server. A scheme of <code>&quot;socks5&quot;</code> will resolve hosts locally, a scheme of <code>&quot;socks5h&quot;</code> will resolve hosts on the SOCKS server. If the URI has a userinfo component it will be sent to the SOCKS server as a username and password.</li>
</ul>
<p>Returns a <em>http.socks</em> object.</p>
</section>
<section id="http.socks.fdopen" class="level3">
<h3><code>fdopen(socket)</code> <!-- --></h3>
<ul>
<li><code>socket</code> should be a cqueues socket object</li>
</ul>
<p>Returns a <em>http.socks</em> object.</p>
</section>
<section id="http.socks.needs_resolve" class="level3">
<h3><code>socks.needs_resolve</code> <!-- --></h3>
<p>Specifies if the destination host should be resolved locally.</p>
</section>
<section id="http.socks:clone" class="level3">
<h3><code>socks:clone()</code> <!-- --></h3>
<p>Make a clone of a given socks object.</p>
</section>
<section id="http.socks:add_username_password_auth" class="level3">
<h3><code>socks:add_username_password_auth(username, password)</code> <!-- --></h3>
<p>Add username + password authorisation to the set of allowed authorisation methods with the given credentials.</p>
</section>
<section id="http.socks:negotiate" class="level3">
<h3><code>socks:negotiate(host, port, timeout)</code> <!-- --></h3>
<p>Complete the SOCKS connection.</p>
<ul>
<li><code>host</code> (required) a string to pass to the SOCKS server as the host to connect to. Will be resolved locally if <a href="#http.socks.needs_resolve"><code>.needs_resolve</code></a> is <code>true</code></li>
<li><code>port</code> (required) a number to pass to the SOCKS server as the port to connect to</li>
</ul>
</section>
<section id="http.socks:close" class="level3">
<h3><code>socks:close()</code> <!-- --></h3>
</section>
<section id="http.socks:take_socket" class="level3">
<h3><code>socks:take_socket()</code> <!-- --></h3>
<p>Take possesion of the socket object managed by the http.socks object. Returns the socket (or <code>nil</code> if not available).</p>
</section>
</section>
<section id="http.stream_common" class="level2">
<h2>http.stream_common</h2>
<p>The module <code>http.stream_common</code> provides common functions for streams (no matter the underlying protocol version). It exports a table <code>methods</code> of functions that build on top of the lower level <a href="#stream"><em>stream</em></a> interface.</p>
<section id="http.stream_common:checktls" class="level3">
<h3><code>stream:checktls()</code> <!-- --></h3>
<p>Convenience wrapper equivalent to <code>stream.connection:checktls()</code></p>
</section>
<section id="http.stream_common:localname" class="level3">
<h3><code>stream:localname()</code> <!-- --></h3>
<p>Convenience wrapper equivalent to <code>stream.connection:localname()</code></p>
</section>
<section id="http.stream_common:peername" class="level3">
<h3><code>stream:peername()</code> <!-- --></h3>
<p>Convenience wrapper equivalent to <code>stream.connection:peername()</code></p>
</section>
<section id="http.stream_common:write_continue" class="level3">
<h3><code>stream:write_continue(timeout)</code> <!-- --></h3>
<p>Sends a 100-continue header block.</p>
</section>
<section id="http.stream_common:each_chunk" class="level3">
<h3><code>stream:each_chunk()</code> <!-- --></h3>
<p>Iterator over <a href="#stream:get_next_chunk"><code>stream:get_next_chunk()</code></a></p>
</section>
<section id="http.stream_common:get_body_as_string" class="level3">
<h3><code>stream:get_body_as_string(timeout)</code> <!-- --></h3>
</section>
<section id="http.stream_common:get_body_chars" class="level3">
<h3><code>stream:get_body_chars(n, timeout)</code> <!-- --></h3>
</section>
<section id="http.stream_common:get_body_until" class="level3">
<h3><code>stream:get_body_until(pattern, plain, include_pattern, timeout)</code> <!-- --></h3>
</section>
<section id="http.stream_common:save_body_to_file" class="level3">
<h3><code>stream:save_body_to_file(file, timeout)</code> <!-- --></h3>
</section>
<section id="http.stream_common:get_body_as_file" class="level3">
<h3><code>stream:get_body_as_file(timeout)</code> <!-- --></h3>
</section>
<section id="http.stream_common:write_body_from_string" class="level3">
<h3><code>stream:write_body_from_string(str, timeout)</code> <!-- --></h3>
</section>
<section id="http.stream_common:write_body_from_file" class="level3">
<h3><code>stream:write_body_from_file(file, timeout)</code> <!-- --></h3>
</section>
</section>
<section id="http.tls" class="level2">
<h2>http.tls</h2>
<section id="http.tls.has_alpn" class="level3">
<h3><code>has_alpn</code> <!-- --></h3>
<p>Boolean indicating if ALPN is available in the current environment.</p>
<p>It may be disabled if OpenSSL was compiled without ALPN support, or is an old version.</p>
</section>
<section id="http.tls.modern_cipher_list" class="level3">
<h3><code>modern_cipher_list</code> <!-- --></h3>
<p>The <a href="https://wiki.mozilla.org/Security/Server_Side_TLS#Modern_compatibility">Mozilla &quot;Modern&quot; cipher list</a> as a colon seperated list, ready to pass to OpenSSL</p>
</section>
<section id="http.tls.intermediate_cipher_list" class="level3">
<h3><code>intermediate_cipher_list</code> <!-- --></h3>
<p>The <a href="https://wiki.mozilla.org/Security/Server_Side_TLS#Intermediate_compatibility_.28default.29">Mozilla &quot;Intermediate&quot; cipher list</a> as a colon seperated list, ready to pass to OpenSSL</p>
</section>
<section id="http.tls.banned_ciphers" class="level3">
<h3><code>banned_ciphers</code> <!-- --></h3>
<p>A set (table with string keys and values of <code>true</code>) of the <a href="https://http2.github.io/http2-spec/#BadCipherSuites">ciphers banned in HTTP 2</a> where the keys are OpenSSL cipher names.</p>
<p>Ciphers not known by OpenSSL are missing from the set.</p>
</section>
<section id="http.tls.new_client_context" class="level3">
<h3><code>new_client_context()</code> <!-- --></h3>
</section>
<section id="http.tls.new_server_context" class="level3">
<h3><code>new_server_context()</code> <!-- --></h3>
</section>
</section>
<section id="http.util" class="level2">
<h2>http.util</h2>
<section id="http.util.encodeURI" class="level3">
<h3><code>encodeURI(str)</code> <!-- --></h3>
</section>
<section id="http.util.encodeURIComponent" class="level3">
<h3><code>encodeURIComponent(str)</code> <!-- --></h3>
</section>
<section id="http.util.decodeURI" class="level3">
<h3><code>decodeURI(str)</code> <!-- --></h3>
</section>
<section id="http.util.decodeURIComponent" class="level3">
<h3><code>decodeURIComponent(str)</code> <!-- --></h3>
</section>
<section id="http.util.query_args" class="level3">
<h3><code>query_args(str)</code> <!-- --></h3>
<p>Returns an iterator over the pairs in <code>str</code></p>
<section id="example-2" class="level4">
<h4>Example</h4>
<div class="sourceCode"><pre class="sourceCode lua"><code class="sourceCode lua"><span class="kw">local</span> http_util <span class="ot">=</span> <span class="fu">require</span> <span class="st">&quot;http.util&quot;</span>
<span class="kw">for</span> name<span class="ot">,</span> value <span class="kw">in</span> http_util<span class="ot">.</span>query_args<span class="ot">(</span><span class="st">&quot;foo=bar&amp;baz=qux&quot;</span><span class="ot">)</span> <span class="kw">do</span>
    <span class="fu">print</span><span class="ot">(</span>name<span class="ot">,</span> value<span class="ot">)</span>
<span class="kw">end</span>
<span class="do">--[[ prints:</span>
<span class="do">&quot;foo&quot;, &quot;bar&quot;</span>
<span class="do">&quot;baz&quot;, &quot;qux&quot;</span>
<span class="do">]]</span></code></pre></div>
</section>
</section>
<section id="http.util.dict_to_query" class="level3">
<h3><code>dict_to_query(dict)</code> <!-- --></h3>
<p>Converts a dictionary (table with string keys) with string values to an encoded query string.</p>
<section id="example-3" class="level4">
<h4>Example</h4>
<div class="sourceCode"><pre class="sourceCode lua"><code class="sourceCode lua"><span class="kw">local</span> http_util <span class="ot">=</span> <span class="fu">require</span> <span class="st">&quot;http.util&quot;</span>
<span class="fu">print</span><span class="ot">(</span>http_util<span class="ot">.</span>dict_to_query<span class="ot">({</span>foo <span class="ot">=</span> <span class="st">&quot;bar&quot;</span><span class="ot">;</span> baz <span class="ot">=</span> <span class="st">&quot;qux&quot;</span><span class="ot">}))</span> <span class="do">--&gt; &quot;baz=qux&amp;foo=bar&quot;</span></code></pre></div>
</section>
</section>
<section id="http.util.resolve_relative_path" class="level3">
<h3><code>resolve_relative_path(orig_path, relative_path)</code> <!-- --></h3>
</section>
<section id="http.util.scheme_to_port" class="level3">
<h3><code>scheme_to_port</code> <!-- --></h3>
<p>Map from schemes (as strings) to default ports (as integers).</p>
</section>
<section id="http.util.split_authority" class="level3">
<h3><code>split_authority(authority, scheme)</code> <!-- --></h3>
<p>Splits an <code>authority</code> into host and port components. If the authority has no port component, will attempt to use the default for the <code>scheme</code>.</p>
<section id="example-4" class="level4">
<h4>Example</h4>
<div class="sourceCode"><pre class="sourceCode lua"><code class="sourceCode lua"><span class="kw">local</span> http_util <span class="ot">=</span> <span class="fu">require</span> <span class="st">&quot;http.util&quot;</span>
<span class="fu">print</span><span class="ot">(</span>http_util<span class="ot">.</span>split_authority<span class="ot">(</span><span class="st">&quot;localhost:8000&quot;</span><span class="ot">,</span> <span class="st">&quot;http&quot;</span><span class="ot">))</span> <span class="do">--&gt; &quot;localhost&quot;, 8000</span>
<span class="fu">print</span><span class="ot">(</span>http_util<span class="ot">.</span>split_authority<span class="ot">(</span><span class="st">&quot;example.com&quot;</span><span class="ot">,</span> <span class="st">&quot;https&quot;</span><span class="ot">))</span> <span class="do">--&gt; &quot;localhost&quot;, 443</span></code></pre></div>
</section>
</section>
<section id="http.util.to_authority" class="level3">
<h3><code>to_authority(host, port, scheme)</code> <!-- --></h3>
<p>Joins the <code>host</code> and <code>port</code> to create a valid authority component. Omits the port if it is the default for the <code>scheme</code>.</p>
</section>
<section id="http.util.imf_date" class="level3">
<h3><code>imf_date(time)</code> <!-- --></h3>
<p>Returns the time in HTTP preferred date format (See <a href="https://tools.ietf.org/html/rfc7231#section-7.1.1.1">RFC 7231 section 7.1.1.1</a>)</p>
<p><code>time</code> defaults to the current time</p>
</section>
<section id="http.util.maybe_quote" class="level3">
<h3><code>maybe_quote(str)</code> <!-- --></h3>
<ul>
<li>If <code>str</code> is a valid <code>token</code>, return it as-is.</li>
<li>If <code>str</code> would be valid as a <code>quoted-string</code>, return the quoted version</li>
<li>Otherwise, returns <code>nil</code></li>
</ul>
</section>
</section>
<section id="http.version" class="level2">
<h2>http.version</h2>
<section id="http.version.name" class="level3">
<h3><code>name</code> <!-- --></h3>
<p><code>&quot;lua-http&quot;</code></p>
</section>
<section id="http.version.version" class="level3">
<h3><code>version</code> <!-- --></h3>
<p>Current version of lua-http as a string.</p>
</section>
</section>
<section id="http.websocket" class="level2">
<h2>http.websocket</h2>
<section id="http.websocket.new_from_uri" class="level3">
<h3><code>new_from_uri(uri, protocols)</code> <!-- --></h3>
<p>Creates a new <code>http.websocket</code> object of type <code>&quot;client&quot;</code> from the given URI.</p>
<ul>
<li><code>protocols</code> (optional) should be a lua table containing a sequence of protocols to send to the server</li>
</ul>
</section>
<section id="http.websocket.new_from_stream" class="level3">
<h3><code>new_from_stream(stream, headers)</code> <!-- --></h3>
<p>Attempts to create a new <code>http.websocket</code> object of type <code>&quot;server&quot;</code> from the given request headers and stream.</p>
<ul>
<li><a href="#http.h1_stream"><code>stream</code></a> should be a live HTTP 1 stream of the <code>&quot;server&quot;</code> type.</li>
<li><a href="#http.headers"><code>headers</code></a> should be headers of a suspected websocket upgrade request from an HTTP 1 client.</li>
</ul>
<p>This function does <strong>not</strong> have side effects, and is hence okay to use tentatively.</p>
</section>
<section id="http.websocket.close_timeout" class="level3">
<h3><code>websocket.close_timeout</code> <!-- --></h3>
<p>Amount of time (in seconds) to wait between sending a close frame and actually closing the connection. Defaults to <code>3</code> seconds.</p>
</section>
<section id="http.websocket:accept" class="level3">
<h3><code>websocket:accept(options, timeout)</code> <!-- --></h3>
<p>Completes negotiation with a websocket client.</p>
<ul>
<li><p><code>options</code> is a table containing:</p>
<ul>
<li><code>headers</code> (optional) a <a href="#http.headers">headers</a> object to use as a prototype for the response headers</li>
<li><code>protocols</code> (optional) should be a lua table containing a sequence of protocols to allow from the client</li>
</ul></li>
</ul>
<p>Usually called after a successful <a href="#http.websocket.new_from_stream"><code>new_from_stream</code></a></p>
</section>
<section id="http.websocket:connect" class="level3">
<h3><code>websocket:connect(timeout)</code> <!-- --></h3>
<p>Connect to a websocket server.</p>
<p>Usually called after a successful <a href="#http.websocket.new_from_uri"><code>new_from_uri</code></a></p>
</section>
<section id="http.websocket:receive" class="level3">
<h3><code>websocket:receive(timeout)</code> <!-- --></h3>
<p>Reads and returns the next data frame plus its opcode. Any ping frames received while reading will be responded to.</p>
<p>The opcode <code>0x1</code> will be returned as <code>&quot;text&quot;</code> and <code>0x2</code> will be returned as <code>&quot;binary&quot;</code>.</p>
</section>
<section id="http.websocket:each" class="level3">
<h3><code>websocket:each()</code> <!-- --></h3>
<p>Iterator over <a href="#http.websocket:receive"><code>websocket:receive()</code></a>.</p>
</section>
<section id="http.websocket:send_frame" class="level3">
<h3><code>websocket:send_frame(frame, timeout)</code> <!-- --></h3>
<p>Low level function to send a raw frame.</p>
</section>
<section id="http.websocket:send" class="level3">
<h3><code>websocket:send(data, opcode, timeout)</code> <!-- --></h3>
<p>Send the given <code>data</code> as a data frame.</p>
<ul>
<li><code>data</code> should be a string</li>
<li><code>opcode</code> can be a numeric opcode, <code>&quot;text&quot;</code> or <code>&quot;binary&quot;</code>. If <code>nil</code>, defaults to a text frame</li>
</ul>
</section>
<section id="http.websocket:send_ping" class="level3">
<h3><code>websocket:send_ping(data, timeout)</code> <!-- --></h3>
<p>Sends a ping frame.</p>
<ul>
<li><code>data</code> is optional</li>
</ul>
</section>
<section id="http.websocket:send_pong" class="level3">
<h3><code>websocket:send_pong(data, timeout)</code> <!-- --></h3>
<p>Sends a pong frame. Works as a unidirectional keepalive.</p>
<ul>
<li><code>data</code> is optional</li>
</ul>
</section>
<section id="http.websocket:close" class="level3">
<h3><code>websocket:close(code, reason, timeout)</code> <!-- --></h3>
<p>Closes the websocket connection.</p>
<ul>
<li><code>code</code> defaults to <code>1000</code></li>
<li><code>reason</code> is an optional string</li>
</ul>
</section>
</section>
<section id="http.zlib" class="level2">
<h2>http.zlib</h2>
<p>An abstraction layer over the various lua zlib libraries.</p>
<section id="http.zlib.engine" class="level3">
<h3><code>engine</code> <!-- --></h3>
<p>Currently either <a href="https://github.com/brimworks/lua-zlib"><code>&quot;lua-zlib&quot;</code></a> or <a href="https://github.com/LuaDist/lzlib"><code>&quot;lzlib&quot;</code></a></p>
</section>
<section id="http.zlib.inflate" class="level3">
<h3><code>inflate()</code> <!-- --></h3>
<p>Returns a function that inflates (uncompresses) a zlib stream.</p>
<p>The function takes a string of compressed data and an end of stream flag, it returns the uncompressed data as a string. It will throw an error if the stream is invalid</p>
</section>
<section id="http.zlib.deflate" class="level3">
<h3><code>deflate()</code> <!-- --></h3>
<p>Returns a function that deflates (compresses) a zlib stream.</p>
<p>The function takes a string of uncompressed data and an end of stream flag, it returns the compressed data as a string.</p>
</section>
<section id="http.zlib-example" class="level3">
<h3>Example</h3>
<div class="sourceCode"><pre class="sourceCode lua"><code class="sourceCode lua"><span class="kw">local</span> zlib <span class="ot">=</span> <span class="fu">require</span> <span class="st">&quot;http.zlib&quot;</span>
<span class="kw">local</span> original <span class="ot">=</span> <span class="st">&quot;the racecar raced around the racecar track&quot;</span>
<span class="kw">local</span> deflater <span class="ot">=</span> zlib<span class="ot">.</span>deflate<span class="ot">()</span>
<span class="kw">local</span> compressed <span class="ot">=</span> deflater<span class="ot">(</span>original<span class="ot">,</span> <span class="kw">true</span><span class="ot">)</span>
<span class="fu">print</span><span class="ot">(#</span>original<span class="ot">,</span> <span class="ot">#</span>compressed<span class="ot">)</span> <span class="do">-- compressed should be smaller</span>
<span class="kw">local</span> inflater <span class="ot">=</span> zlib<span class="ot">.</span>inflate<span class="ot">()</span>
<span class="kw">local</span> uncompressed <span class="ot">=</span> inflater<span class="ot">(</span>compressed<span class="ot">,</span> <span class="kw">true</span><span class="ot">)</span>
<span class="fu">assert</span><span class="ot">(</span>original <span class="ot">==</span> uncompressed<span class="ot">)</span></code></pre></div>
</section>
</section>
<section id="http.compat.prosody" class="level2">
<h2>http.compat.prosody</h2>
<p>Provides usage similar to <a href="https://prosody.im/doc/developers/net/http">prosody's net.http</a></p>
<section id="http.compat.prosody.request" class="level3">
<h3><code>request(url, ex, callback)</code> <!-- --></h3>
<p>A few key differences to the prosody <code>net.http.request</code>:</p>
<ul>
<li>must be called from within a running cqueue</li>
<li>The callback may be called from a different thread in the cqueue</li>
<li>The returned object will be a <a href="#http.request"><em>http.request</em></a> object
<ul>
<li>This object is passed to the callback on errors and as the 4th argument on success</li>
</ul></li>
<li>The default user-agent will be from lua-http (rather than <code>&quot;Prosody XMPP Server&quot;</code>)</li>
<li>lua-http features (such as HTTP2) will be used where possible</li>
</ul>
</section>
<section id="http.compat.prosody-example" class="level3">
<h3>Example</h3>
<div class="sourceCode"><pre class="sourceCode lua"><code class="sourceCode lua"><span class="kw">local</span> prosody_http <span class="ot">=</span> <span class="fu">require</span> <span class="st">&quot;http.compat.prosody&quot;</span>
<span class="kw">local</span> cqueues <span class="ot">=</span> <span class="fu">require</span> <span class="st">&quot;cqueues&quot;</span>
<span class="kw">local</span> cq <span class="ot">=</span> cqueues<span class="ot">.</span>new<span class="ot">()</span>
cq:wrap<span class="ot">(</span><span class="kw">function</span><span class="ot">()</span>
    prosody_http<span class="ot">.</span>request<span class="ot">(</span><span class="st">&quot;http://httpbin.org/ip&quot;</span><span class="ot">,</span> <span class="ot">{},</span> <span class="kw">function</span><span class="ot">(</span>b<span class="ot">,</span> c<span class="ot">,</span> r<span class="ot">)</span>
        <span class="fu">print</span><span class="ot">(</span>c<span class="ot">)</span> <span class="do">--&gt; 200</span>
        <span class="fu">print</span><span class="ot">(</span>b<span class="ot">)</span> <span class="do">--&gt; {&quot;origin&quot;: &quot;123.123.123.123&quot;}</span>
    <span class="kw">end</span><span class="ot">)</span>
<span class="kw">end</span><span class="ot">)</span>
<span class="fu">assert</span><span class="ot">(</span>cq:loop<span class="ot">())</span></code></pre></div>
</section>
</section>
<section id="http.compat.socket" class="level2">
<h2>http.compat.socket</h2>
<p>Provides compatibility with <a href="http://w3.impa.br/~diego/software/luasocket/http.html">luasocket's http.request module</a>.</p>
<p>Differences:</p>
<ul>
<li>Will automatically be non-blocking when run inside a cqueues managed coroutine</li>
<li>lua-http features (such as HTTP2) will be used where possible</li>
</ul>
<section id="http.compat.socket-example" class="level3">
<h3>Example</h3>
<p>Using the 'simple' interface as part of a normal script:</p>
<div class="sourceCode"><pre class="sourceCode lua"><code class="sourceCode lua"><span class="kw">local</span> socket_http <span class="ot">=</span> <span class="fu">require</span> <span class="st">&quot;http.compat.socket&quot;</span>
<span class="kw">local</span> body<span class="ot">,</span> code <span class="ot">=</span> <span class="fu">assert</span><span class="ot">(</span>socket_http<span class="ot">.</span>request<span class="ot">(</span><span class="st">&quot;http://lua.org&quot;</span><span class="ot">))</span>
<span class="fu">print</span><span class="ot">(</span>code<span class="ot">,</span> <span class="ot">#</span>body<span class="ot">)</span> <span class="do">--&gt; 200, 2514</span></code></pre></div>
</section>
</section>
</section>
<section id="links" class="level1">
<h1>Links</h1>
<ul>
<li><a href="https://github.com/daurnimator/lua-http">Github</a></li>
<li><a href="https://github.com/daurnimator/lua-http/issues">Issue tracker</a></li>
</ul>
</section>
</main>
</body>
</html>
